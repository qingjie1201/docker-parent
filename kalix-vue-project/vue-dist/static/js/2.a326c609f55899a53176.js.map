{"version":3,"sources":["webpack:///./node_modules/core-js/library/modules/es7.weak-map.from.js","webpack:///./node_modules/babel-runtime/core-js/object/create.js","webpack:///./node_modules/core-js/library/fn/weak-map.js","webpack:///./node_modules/babel-runtime/core-js/weak-map.js","webpack:///./node_modules/core-js/library/modules/_collection-weak.js","webpack:///./node_modules/core-js/library/modules/es6.weak-map.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///(webpack)/buildin/amd-options.js","webpack:///./node_modules/core-js/library/fn/object/create.js","webpack:///./src/components/squire/squire-raw.js","webpack:///./node_modules/core-js/library/modules/es6.object.create.js","webpack:///./node_modules/core-js/library/modules/es7.weak-map.of.js"],"names":["__webpack_require__","module","exports","default","__esModule","WeakMap","redefineAll","getWeak","anObject","isObject","anInstance","forOf","createArrayMethod","$has","validate","arrayFind","arrayFindIndex","id","uncaughtFrozenStore","that","_l","UncaughtFrozenStore","this","a","findUncaughtFrozen","store","key","it","prototype","get","entry","has","set","value","push","delete","index","splice","getConstructor","wrapper","NAME","IS_MAP","ADDER","C","iterable","_t","_i","undefined","data","def","ufstore","InternalMap","each","redefine","meta","assign","weak","fails","WEAK_MAP","isExtensible","Object","tmp","arguments","length","methods","$WeakMap","freeze","NEED","proto","method","b","_f","result","call","originalModule","webpackPolyfill","create","children","defineProperty","enumerable","l","i","__webpack_amd_options__","$Object","P","D","doc","TreeWalker","root","nodeType","filter","currentNode","isLeaf","node","ELEMENT_NODE","leafNodeNames","nodeName","getNodeCategory","TEXT_NODE","INLINE","DOCUMENT_FRAGMENT_NODE","canWeakMap","nodeCategoryCache","UNKNOWN","nodeCategory","nodeList","fn","every","childNodes","isInline","inlineNodeNames","test","BLOCK","CONTAINER","isBlock","isContainer","getBlockWalker","walker","SHOW_ELEMENT","getPreviousBlock","previousNode","getNextBlock","nextNode","isEmptyBlock","block","textContent","querySelector","areAlike","node2","className","style","cssText","hasTagAttributes","tag","attributes","attr","getAttribute","getNearest","parentNode","isOrContains","parent","getPath","classNames","dir","path","trim","split","sort","join","indexOf","HIGHLIGHT_CLASS","backgroundColor","replace","COLOUR_CLASS","color","FONT_FAMILY_CLASS","fontFamily","FONT_SIZE_CLASS","fontSize","getLength","detach","removeChild","replaceWith","replaceChild","empty","frag","ownerDocument","createDocumentFragment","appendChild","firstChild","createElement","props","el","Array","setAttribute","fixCursor","fixer","child","self","__squire__","originalNode","createDefaultBlock","cantFocusEmptyTextNodes","createTextNode","ZWS","_didAddZWS","useTextFixer","insertBefore","lastElementChild","error","didError","name","message","innerHTML","fixContainer","container","isBR","config","_config","blockTag","blockAttributes","offset","stopNode","clone","next","splitText","cloneNode","nextSibling","start","_mergeInlines","fakeRange","prev","len","frags","startContainer","startOffset","endContainer","endOffset","appendData","pop","mergeInlines","range","setStart","setEnd","mergeWithBlock","last","lastChild","collapse","isPresto","mergeContainers","needsFix","previousSibling","first","isListItem","monitorShiftKey","event","isShiftDown","shiftKey","mergeObjects","base","extras","mayOverride","prop","constructor","Squire","DOCUMENT_NODE","body","mutation","win","defaultView","_win","_doc","_root","_events","_isFocused","_lastSelection","losesSelectionOnBlur","addEventListener","getSelection","_hasZWS","_lastAnchorNode","_lastFocusNode","_path","_willUpdatePath","_updatePathOnEvent","_undoIndex","_undoStack","_undoStackLength","_isInUndoState","_ignoreChange","_ignoreAllChanges","canObserveMutations","MutationObserver","_docWasChanged","bind","observe","childList","characterData","subtree","_mutation","_keyUpDetectChange","_restoreSelection","enableRestoreSelection","disableRestoreSelection","restoreSelection","_awaitingPaste","isIElt11","onCut","onCopy","onPaste","onDrop","onKey","_keyHandlers","__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_create___default","keyHandlers","setConfig","Text","afterSplit","slice","toDelete","deleteData","execCommand","setHTML","setSelection","removeFormatting","clean","ua","navigator","userAgent","isAndroid","isIOS","isMac","isWin","isGecko","opera","isEdge","isWebKit","isIE","ctrlKey","__WEBPACK_IMPORTED_MODULE_2_babel_runtime_core_js_weak_map___default","notWS","F","typeToBitArray","1","2","3","8","9","11","current","previousPONode","BR","HR","IFRAME","IMG","INPUT","getNodeBefore","getNodeAfter","insertNodeInRange","childCount","collapsed","extractContentsOfRange","common","commonAncestorContainer","before","after","endNode","startNode","deleteContentsOfRange","startBlock","getStartBlockOfRange","endBlock","getEndBlockOfRange","needsMerge","moveRangeBoundariesDownTree","moveRangeBoundariesUpTree","selectNodeContents","insertTreeFragmentIntoRange","blockContentsAfterSplit","stopPoint","replaceBlock","firstBlockInFrag","nodeAfterSplit","nodeBeforeSplit","tempRange","cleanupBRs","setEndBefore","cloneRange","isNodeContainedInRange","partial","nodeRange","createRange","selectNode","nodeEndBeforeStart","compareBoundaryPoints","nodeStartAfterEnd","nodeStartAfterStart","nodeEndBeforeEnd","maySkipBR","startMax","endMax","contentWalker","rangeDoesStartAtBlockBoundary","nodeAfterCursor","rangeDoesEndAtBlockBoundary","expandRangeToBlockBoundaries","end","keys","13","32","33","34","37","39","46","219","221","code","keyCode","modifiers","defaultPrevented","String","fromCharCode","toLowerCase","which","altKey","metaKey","saveUndoState","_ensureBottomLine","_updatePath","mapKeyTo","preventDefault","mapKeyToFormat","remove","hasFormat","changeFormat","afterDelete","enter","_recordUndoState","addLinks","_removeZWS","_getRangeAndRemoveBookmark","decreaseListLevel","modifyBlocks","removeBlockQuote","splitBlock","removeZWS","removeEmptyInlines","_createRange","backspace","previous","isContentEditable","decreaseBlockQuoteLevel","setTimeout","originalRange","cursorContainer","cursorOffset","tab","increaseListLevel","shift-tab","space","_","setStartAfter","left","right","sel","getWindowSelection","modify","pageup","moveCursorToStart","pagedown","moveCursorToEnd","fontSizes","4","5","6","7","styleToSemantic","regexp","colour","class","fontWeight","fontStyle","family","size","textDecoration","replaceWithTag","replaceStyles","converter","css","newTreeBottom","newTreeTop","stylesRewriters","SPAN","STRONG","EM","INS","STRIKE","FONT","fontSpan","sizeSpan","colourSpan","face","charAt","TT","allowedBlock","blacklist","cleanTree","preserveWS","nonInlineParent","rewriter","childLength","startsWithWS","endsWithWS","sibling","notWSTextNode","isLineBreak","br","isLBIfEmptyBlock","keepForBlankLine","brs","querySelectorAll","brBreaksLine","setClipboardData","clipboardData","html","text","innerText","setData","copyRoot","contents","newContents","cloneContents","item","type","types","items","choosePlain","fireDrop","hasImage","plainItem","getAsString","insertHTML","fireEvent","dataTransfer","insertPlainText","getData","pasteArea","contenteditable","hasPlain","hasHTML","tagAttributes","blockquote","ul","ol","li","undo","documentSizeThreshold","undoLimit","isInsertedHTMLSanitized","isSetHTMLSanitized","sanitizeToDOMFragment","DOMPurify","isSupported","isPaste","sanitize","ALLOW_UNKNOWN_PROTOCOLS","WHOLE_DOCUMENT","RETURN_DOM","RETURN_DOM_FRAGMENT","importNode","toUpperCase","console","log","getDocument","getRoot","modifyDocument","modificationCallback","takeRecords","disconnect","customEvents","pathChange","select","input","undoStateChange","isFocused","obj","handlers","activeElement","handleEvent","details","destroy","events","removeEventListener","target","Range","domRange","getCursorPosition","getBoundingClientRect","rect","top","_moveCursorTo","toStart","blur","focus","removeAllRanges","addRange","selection","rangeCount","getRangeAt","setStartBefore","getSelectedText","addedTextInBlock","keepNode","force","newPath","anchor","startSelectionId","endSelectionId","_saveRangeToBookmark","temp","compareDocumentPosition","canUndo","canRedo","undoIndex","undoStack","undoConfig","undoThreshold","_getHTML","_setHTML","redo","undoStackLength","setEndAfter","seenNode","getFontInfo","element","fontInfo","seenAttributes","_addFormat","_removeFormat","toWrap","formatTags","getElementsByTagName","forEach","examineNode","exemplar","isText","add","tagAfterSplit","DT","DD","LI","PRE","splitTag","splitProperties","forEachBlock","mutates","blockquotes","makeList","newLi","listAttrs","listItemAttrs","getListSelection","list","startLi","endLi","listSelection","newParent","makeNotList","setKeyHandler","getHTML","withBookMark","div","insertElement","splitNode","insertImage","src","img","linkRegExp","match","endIndex","defaultAttributes","exec","href","startFragmentIndex","endFragmentIndex","lastIndexOf","fragment","normalize","escapeHTMLFragement","plainText","line","lines","closeBlock","openBlock","command","arg","arg2","addStyles","styles","head","documentElement","bold","italic","underline","strikethrough","subscript","superscript","removeBold","removeItalic","removeUnderline","removeStrikethrough","removeSubscript","removeSuperscript","makeLink","url","protocolEnd","removeLink","setFontFace","setFontSize","setTextColour","setHighlightColour","setTextAlignment","alignment","klass","textAlign","setTextDirection","direction","removeAttribute","removeAllFormatting","formattedNodes","cleanNodes","nodeInSplit","increaseQuoteLevel","decreaseQuoteLevel","makeUnorderedList","makeOrderedList","removeList","listFrag","lists","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_typeof___default","define","editor","onEditorLoad","document","$export","S"],"mappings":"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","file":"static/js/2.a326c609f55899a53176.js","sourcesContent":["// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from\nrequire('./_set-collection-from')('WeakMap');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es7.weak-map.from.js\n// module id = OPyX\n// module chunks = 1 2","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/create.js\n// module id = OvRC\n// module chunks = 1 2","require('../modules/es6.object.to-string');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.weak-map');\nrequire('../modules/es7.weak-map.of');\nrequire('../modules/es7.weak-map.from');\nmodule.exports = require('../modules/_core').WeakMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/weak-map.js\n// module id = PlIm\n// module chunks = 1 2","module.exports = { \"default\": require(\"core-js/library/fn/weak-map\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/weak-map.js\n// module id = XFB5\n// module chunks = 1 2","'use strict';\nvar redefineAll = require('./_redefine-all');\nvar getWeak = require('./_meta').getWeak;\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar createArrayMethod = require('./_array-methods');\nvar $has = require('./_has');\nvar validate = require('./_validate-collection');\nvar arrayFind = createArrayMethod(5);\nvar arrayFindIndex = createArrayMethod(6);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_collection-weak.js\n// module id = XVP1\n// module chunks = 1 2","'use strict';\nvar each = require('./_array-methods')(0);\nvar redefine = require('./_redefine');\nvar meta = require('./_meta');\nvar assign = require('./_object-assign');\nvar weak = require('./_collection-weak');\nvar isObject = require('./_is-object');\nvar fails = require('./_fails');\nvar validate = require('./_validate-collection');\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = weak.ufstore;\nvar tmp = {};\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return weak.def(validate(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\n  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.weak-map.js\n// module id = aY9x\n// module chunks = 1 2","module.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/harmony-module.js\n// module id = f1Eh\n// module chunks = 1 2","/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/amd-options.js\n// module id = nErl\n// module chunks = 1 2","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/create.js\n// module id = oM7Q\n// module chunks = 1 2","/* eslint-disable */\r\n/* Copyright © 2011-2015 by Neil Jenkins. MIT Licensed. */\r\n( function ( doc, undefined ) {\r\n\r\n\"use strict\";\r\n\r\nvar DOCUMENT_POSITION_PRECEDING = 2; // Node.DOCUMENT_POSITION_PRECEDING\r\nvar ELEMENT_NODE = 1;                // Node.ELEMENT_NODE;\r\nvar TEXT_NODE = 3;                   // Node.TEXT_NODE;\r\nvar DOCUMENT_NODE = 9;               // Node.DOCUMENT_NODE;\r\nvar DOCUMENT_FRAGMENT_NODE = 11;     // Node.DOCUMENT_FRAGMENT_NODE;\r\nvar SHOW_ELEMENT = 1;                // NodeFilter.SHOW_ELEMENT;\r\nvar SHOW_TEXT = 4;                   // NodeFilter.SHOW_TEXT;\r\n\r\nvar START_TO_START = 0; // Range.START_TO_START\r\nvar START_TO_END = 1;   // Range.START_TO_END\r\nvar END_TO_END = 2;     // Range.END_TO_END\r\nvar END_TO_START = 3;   // Range.END_TO_START\r\n\r\nvar HIGHLIGHT_CLASS = 'highlight';\r\nvar COLOUR_CLASS = 'colour';\r\nvar FONT_FAMILY_CLASS = 'font';\r\nvar FONT_SIZE_CLASS = 'size';\r\n\r\nvar ZWS = '\\u200B';\r\n\r\nvar win = doc.defaultView;\r\n\r\nvar ua = navigator.userAgent;\r\n\r\nvar isAndroid = /Android/.test( ua );\r\nvar isIOS = /iP(?:ad|hone|od)/.test( ua );\r\nvar isMac = /Mac OS X/.test( ua );\r\nvar isWin = /Windows NT/.test( ua );\r\n\r\nvar isGecko = /Gecko\\//.test( ua );\r\nvar isIElt11 = /Trident\\/[456]\\./.test( ua );\r\nvar isPresto = !!win.opera;\r\nvar isEdge = /Edge\\//.test( ua );\r\nvar isWebKit = !isEdge && /WebKit\\//.test( ua );\r\nvar isIE = /Trident\\/[4567]\\./.test( ua );\r\n\r\nvar ctrlKey = isMac ? 'meta-' : 'ctrl-';\r\n\r\nvar useTextFixer = isIElt11 || isPresto;\r\nvar cantFocusEmptyTextNodes = isIElt11 || isWebKit;\r\nvar losesSelectionOnBlur = isIElt11;\r\n\r\nvar canObserveMutations = typeof MutationObserver !== 'undefined';\r\nvar canWeakMap = typeof WeakMap !== 'undefined';\r\n\r\n// Use [^ \\t\\r\\n] instead of \\S so that nbsp does not count as white-space\r\nvar notWS = /[^ \\t\\r\\n]/;\r\n\r\nvar indexOf = Array.prototype.indexOf;\r\n\r\n// Polyfill for FF3.5\r\nif ( !Object.create ) {\r\n    Object.create = function ( proto ) {\r\n        var F = function () {};\r\n        F.prototype = proto;\r\n        return new F();\r\n    };\r\n}\r\n\r\n/*\r\n    Native TreeWalker is buggy in IE and Opera:\r\n    * IE9/10 sometimes throw errors when calling TreeWalker#nextNode or\r\n      TreeWalker#previousNode. No way to feature detect this.\r\n    * Some versions of Opera have a bug in TreeWalker#previousNode which makes\r\n      it skip to the wrong node.\r\n\r\n    Rather than risk further bugs, it's easiest just to implement our own\r\n    (subset) of the spec in all browsers.\r\n*/\r\n\r\nvar typeToBitArray = {\r\n    // ELEMENT_NODE\r\n    1: 1,\r\n    // ATTRIBUTE_NODE\r\n    2: 2,\r\n    // TEXT_NODE\r\n    3: 4,\r\n    // COMMENT_NODE\r\n    8: 128,\r\n    // DOCUMENT_NODE\r\n    9: 256,\r\n    // DOCUMENT_FRAGMENT_NODE\r\n    11: 1024\r\n};\r\n\r\nfunction TreeWalker ( root, nodeType, filter ) {\r\n    this.root = this.currentNode = root;\r\n    this.nodeType = nodeType;\r\n    this.filter = filter;\r\n}\r\n\r\nTreeWalker.prototype.nextNode = function () {\r\n    var current = this.currentNode,\r\n        root = this.root,\r\n        nodeType = this.nodeType,\r\n        filter = this.filter,\r\n        node;\r\n    while ( true ) {\r\n        node = current.firstChild;\r\n        while ( !node && current ) {\r\n            if ( current === root ) {\r\n                break;\r\n            }\r\n            node = current.nextSibling;\r\n            if ( !node ) { current = current.parentNode; }\r\n        }\r\n        if ( !node ) {\r\n            return null;\r\n        }\r\n        if ( ( typeToBitArray[ node.nodeType ] & nodeType ) &&\r\n                filter( node ) ) {\r\n            this.currentNode = node;\r\n            return node;\r\n        }\r\n        current = node;\r\n    }\r\n};\r\n\r\nTreeWalker.prototype.previousNode = function () {\r\n    var current = this.currentNode,\r\n        root = this.root,\r\n        nodeType = this.nodeType,\r\n        filter = this.filter,\r\n        node;\r\n    while ( true ) {\r\n        if ( current === root ) {\r\n            return null;\r\n        }\r\n        node = current.previousSibling;\r\n        if ( node ) {\r\n            while ( current = node.lastChild ) {\r\n                node = current;\r\n            }\r\n        } else {\r\n            node = current.parentNode;\r\n        }\r\n        if ( !node ) {\r\n            return null;\r\n        }\r\n        if ( ( typeToBitArray[ node.nodeType ] & nodeType ) &&\r\n                filter( node ) ) {\r\n            this.currentNode = node;\r\n            return node;\r\n        }\r\n        current = node;\r\n    }\r\n};\r\n\r\n// Previous node in post-order.\r\nTreeWalker.prototype.previousPONode = function () {\r\n    var current = this.currentNode,\r\n        root = this.root,\r\n        nodeType = this.nodeType,\r\n        filter = this.filter,\r\n        node;\r\n    while ( true ) {\r\n        node = current.lastChild;\r\n        while ( !node && current ) {\r\n            if ( current === root ) {\r\n                break;\r\n            }\r\n            node = current.previousSibling;\r\n            if ( !node ) { current = current.parentNode; }\r\n        }\r\n        if ( !node ) {\r\n            return null;\r\n        }\r\n        if ( ( typeToBitArray[ node.nodeType ] & nodeType ) &&\r\n                filter( node ) ) {\r\n            this.currentNode = node;\r\n            return node;\r\n        }\r\n        current = node;\r\n    }\r\n};\r\n\r\nvar inlineNodeNames  = /^(?:#text|A(?:BBR|CRONYM)?|B(?:R|D[IO])?|C(?:ITE|ODE)|D(?:ATA|EL|FN)|EM|FONT|HR|I(?:FRAME|MG|NPUT|NS)?|KBD|Q|R(?:P|T|UBY)|S(?:AMP|MALL|PAN|TR(?:IKE|ONG)|U[BP])?|TIME|U|VAR|WBR)$/;\r\n\r\nvar leafNodeNames = {\r\n    BR: 1,\r\n    HR: 1,\r\n    IFRAME: 1,\r\n    IMG: 1,\r\n    INPUT: 1\r\n};\r\n\r\nfunction every ( nodeList, fn ) {\r\n    var l = nodeList.length;\r\n    while ( l-- ) {\r\n        if ( !fn( nodeList[l] ) ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// ---\r\n\r\nvar UNKNOWN = 0;\r\nvar INLINE = 1;\r\nvar BLOCK = 2;\r\nvar CONTAINER = 3;\r\n\r\nvar nodeCategoryCache = canWeakMap ? new WeakMap() : null;\r\n\r\nfunction isLeaf ( node ) {\r\n    return node.nodeType === ELEMENT_NODE && !!leafNodeNames[ node.nodeName ];\r\n}\r\nfunction getNodeCategory ( node ) {\r\n    switch ( node.nodeType ) {\r\n    case TEXT_NODE:\r\n        return INLINE;\r\n    case ELEMENT_NODE:\r\n    case DOCUMENT_FRAGMENT_NODE:\r\n        if ( canWeakMap && nodeCategoryCache.has( node ) ) {\r\n            return nodeCategoryCache.get( node );\r\n        }\r\n        break;\r\n    default:\r\n        return UNKNOWN;\r\n    }\r\n\r\n    var nodeCategory;\r\n    if ( !every( node.childNodes, isInline ) ) {\r\n        // Malformed HTML can have block tags inside inline tags. Need to treat\r\n        // these as containers rather than inline. See #239.\r\n        nodeCategory = CONTAINER;\r\n    } else if ( inlineNodeNames.test( node.nodeName ) ) {\r\n        nodeCategory = INLINE;\r\n    } else {\r\n        nodeCategory = BLOCK;\r\n    }\r\n    if ( canWeakMap ) {\r\n        nodeCategoryCache.set( node, nodeCategory );\r\n    }\r\n    return nodeCategory;\r\n}\r\nfunction isInline ( node ) {\r\n    return getNodeCategory( node ) === INLINE;\r\n}\r\nfunction isBlock ( node ) {\r\n    return getNodeCategory( node ) === BLOCK;\r\n}\r\nfunction isContainer ( node ) {\r\n    return getNodeCategory( node ) === CONTAINER;\r\n}\r\n\r\nfunction getBlockWalker ( node, root ) {\r\n    var walker = new TreeWalker( root, SHOW_ELEMENT, isBlock );\r\n    walker.currentNode = node;\r\n    return walker;\r\n}\r\nfunction getPreviousBlock ( node, root ) {\r\n    node = getBlockWalker( node, root ).previousNode();\r\n    return node !== root ? node : null;\r\n}\r\nfunction getNextBlock ( node, root ) {\r\n    node = getBlockWalker( node, root ).nextNode();\r\n    return node !== root ? node : null;\r\n}\r\n\r\nfunction isEmptyBlock ( block ) {\r\n    return !block.textContent && !block.querySelector( 'IMG' );\r\n}\r\n\r\nfunction areAlike ( node, node2 ) {\r\n    return !isLeaf( node ) && (\r\n        node.nodeType === node2.nodeType &&\r\n        node.nodeName === node2.nodeName &&\r\n        node.nodeName !== 'A' &&\r\n        node.className === node2.className &&\r\n        ( ( !node.style && !node2.style ) ||\r\n          node.style.cssText === node2.style.cssText )\r\n    );\r\n}\r\nfunction hasTagAttributes ( node, tag, attributes ) {\r\n    if ( node.nodeName !== tag ) {\r\n        return false;\r\n    }\r\n    for ( var attr in attributes ) {\r\n        if ( node.getAttribute( attr ) !== attributes[ attr ] ) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getNearest ( node, root, tag, attributes ) {\r\n    while ( node && node !== root ) {\r\n        if ( hasTagAttributes( node, tag, attributes ) ) {\r\n            return node;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return null;\r\n}\r\nfunction isOrContains ( parent, node ) {\r\n    while ( node ) {\r\n        if ( node === parent ) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction getPath ( node, root ) {\r\n    var path = '';\r\n    var id, className, classNames, dir;\r\n    if ( node && node !== root ) {\r\n        path = getPath( node.parentNode, root );\r\n        if ( node.nodeType === ELEMENT_NODE ) {\r\n            path += ( path ? '>' : '' ) + node.nodeName;\r\n            if ( id = node.id ) {\r\n                path += '#' + id;\r\n            }\r\n            if ( className = node.className.trim() ) {\r\n                classNames = className.split( /\\s\\s*/ );\r\n                classNames.sort();\r\n                path += '.';\r\n                path += classNames.join( '.' );\r\n            }\r\n            if ( dir = node.dir ) {\r\n                path += '[dir=' + dir + ']';\r\n            }\r\n            if ( classNames ) {\r\n                if ( indexOf.call( classNames, HIGHLIGHT_CLASS ) > -1 ) {\r\n                    path += '[backgroundColor=' +\r\n                        node.style.backgroundColor.replace( / /g,'' ) + ']';\r\n                }\r\n                if ( indexOf.call( classNames, COLOUR_CLASS ) > -1 ) {\r\n                    path += '[color=' +\r\n                        node.style.color.replace( / /g,'' ) + ']';\r\n                }\r\n                if ( indexOf.call( classNames, FONT_FAMILY_CLASS ) > -1 ) {\r\n                    path += '[fontFamily=' +\r\n                        node.style.fontFamily.replace( / /g,'' ) + ']';\r\n                }\r\n                if ( indexOf.call( classNames, FONT_SIZE_CLASS ) > -1 ) {\r\n                    path += '[fontSize=' + node.style.fontSize + ']';\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return path;\r\n}\r\n\r\nfunction getLength ( node ) {\r\n    var nodeType = node.nodeType;\r\n    return nodeType === ELEMENT_NODE || nodeType === DOCUMENT_FRAGMENT_NODE ?\r\n        node.childNodes.length : node.length || 0;\r\n}\r\n\r\nfunction detach ( node ) {\r\n    var parent = node.parentNode;\r\n    if ( parent ) {\r\n        parent.removeChild( node );\r\n    }\r\n    return node;\r\n}\r\nfunction replaceWith ( node, node2 ) {\r\n    var parent = node.parentNode;\r\n    if ( parent ) {\r\n        parent.replaceChild( node2, node );\r\n    }\r\n}\r\nfunction empty ( node ) {\r\n    var frag = node.ownerDocument.createDocumentFragment(),\r\n        childNodes = node.childNodes,\r\n        l = childNodes ? childNodes.length : 0;\r\n    while ( l-- ) {\r\n        frag.appendChild( node.firstChild );\r\n    }\r\n    return frag;\r\n}\r\n\r\nfunction createElement ( doc, tag, props, children ) {\r\n    var el = doc.createElement( tag ),\r\n        attr, value, i, l;\r\n    if ( props instanceof Array ) {\r\n        children = props;\r\n        props = null;\r\n    }\r\n    if ( props ) {\r\n        for ( attr in props ) {\r\n            value = props[ attr ];\r\n            if ( value !== undefined ) {\r\n                el.setAttribute( attr, props[ attr ] );\r\n            }\r\n        }\r\n    }\r\n    if ( children ) {\r\n        for ( i = 0, l = children.length; i < l; i += 1 ) {\r\n            el.appendChild( children[i] );\r\n        }\r\n    }\r\n    return el;\r\n}\r\n\r\nfunction fixCursor ( node, root ) {\r\n    // In Webkit and Gecko, block level elements are collapsed and\r\n    // unfocussable if they have no content. To remedy this, a <BR> must be\r\n    // inserted. In Opera and IE, we just need a textnode in order for the\r\n    // cursor to appear.\r\n    var self = root.__squire__;\r\n    var doc = node.ownerDocument;\r\n    var originalNode = node;\r\n    var fixer, child;\r\n\r\n    if ( node === root ) {\r\n        if ( !( child = node.firstChild ) || child.nodeName === 'BR' ) {\r\n            fixer = self.createDefaultBlock();\r\n            if ( child ) {\r\n                node.replaceChild( fixer, child );\r\n            }\r\n            else {\r\n                node.appendChild( fixer );\r\n            }\r\n            node = fixer;\r\n            fixer = null;\r\n        }\r\n    }\r\n\r\n    if ( node.nodeType === TEXT_NODE ) {\r\n        return originalNode;\r\n    }\r\n\r\n    if ( isInline( node ) ) {\r\n        child = node.firstChild;\r\n        while ( cantFocusEmptyTextNodes && child &&\r\n                child.nodeType === TEXT_NODE && !child.data ) {\r\n            node.removeChild( child );\r\n            child = node.firstChild;\r\n        }\r\n        if ( !child ) {\r\n            if ( cantFocusEmptyTextNodes ) {\r\n                fixer = doc.createTextNode( ZWS );\r\n                self._didAddZWS();\r\n            } else {\r\n                fixer = doc.createTextNode( '' );\r\n            }\r\n        }\r\n    } else {\r\n        if ( useTextFixer ) {\r\n            while ( node.nodeType !== TEXT_NODE && !isLeaf( node ) ) {\r\n                child = node.firstChild;\r\n                if ( !child ) {\r\n                    fixer = doc.createTextNode( '' );\r\n                    break;\r\n                }\r\n                node = child;\r\n            }\r\n            if ( node.nodeType === TEXT_NODE ) {\r\n                // Opera will collapse the block element if it contains\r\n                // just spaces (but not if it contains no data at all).\r\n                if ( /^ +$/.test( node.data ) ) {\r\n                    node.data = '';\r\n                }\r\n            } else if ( isLeaf( node ) ) {\r\n                node.parentNode.insertBefore( doc.createTextNode( '' ), node );\r\n            }\r\n        }\r\n        else if ( !node.querySelector( 'BR' ) ) {\r\n            fixer = createElement( doc, 'BR' );\r\n            while ( ( child = node.lastElementChild ) && !isInline( child ) ) {\r\n                node = child;\r\n            }\r\n        }\r\n    }\r\n    if ( fixer ) {\r\n        try {\r\n            node.appendChild( fixer );\r\n        } catch ( error ) {\r\n            self.didError({\r\n                name: 'Squire: fixCursor – ' + error,\r\n                message: 'Parent: ' + node.nodeName + '/' + node.innerHTML +\r\n                    ' appendChild: ' + fixer.nodeName\r\n            });\r\n        }\r\n    }\r\n\r\n    return originalNode;\r\n}\r\n\r\n// Recursively examine container nodes and wrap any inline children.\r\nfunction fixContainer ( container, root ) {\r\n    var children = container.childNodes;\r\n    var doc = container.ownerDocument;\r\n    var wrapper = null;\r\n    var i, l, child, isBR;\r\n    var config = root.__squire__._config;\r\n\r\n    for ( i = 0, l = children.length; i < l; i += 1 ) {\r\n        child = children[i];\r\n        isBR = child.nodeName === 'BR';\r\n        if ( !isBR && isInline( child ) ) {\r\n            if ( !wrapper ) {\r\n                 wrapper = createElement( doc,\r\n                    config.blockTag, config.blockAttributes );\r\n            }\r\n            wrapper.appendChild( child );\r\n            i -= 1;\r\n            l -= 1;\r\n        } else if ( isBR || wrapper ) {\r\n            if ( !wrapper ) {\r\n                wrapper = createElement( doc,\r\n                    config.blockTag, config.blockAttributes );\r\n            }\r\n            fixCursor( wrapper, root );\r\n            if ( isBR ) {\r\n                container.replaceChild( wrapper, child );\r\n            } else {\r\n                container.insertBefore( wrapper, child );\r\n                i += 1;\r\n                l += 1;\r\n            }\r\n            wrapper = null;\r\n        }\r\n        if ( isContainer( child ) ) {\r\n            fixContainer( child, root );\r\n        }\r\n    }\r\n    if ( wrapper ) {\r\n        container.appendChild( fixCursor( wrapper, root ) );\r\n    }\r\n    return container;\r\n}\r\n\r\nfunction split ( node, offset, stopNode, root ) {\r\n    var nodeType = node.nodeType,\r\n        parent, clone, next;\r\n    if ( nodeType === TEXT_NODE && node !== stopNode ) {\r\n        return split(\r\n            node.parentNode, node.splitText( offset ), stopNode, root );\r\n    }\r\n    if ( nodeType === ELEMENT_NODE ) {\r\n        if ( typeof( offset ) === 'number' ) {\r\n            offset = offset < node.childNodes.length ?\r\n                node.childNodes[ offset ] : null;\r\n        }\r\n        if ( node === stopNode ) {\r\n            return offset;\r\n        }\r\n\r\n        // Clone node without children\r\n        parent = node.parentNode;\r\n        clone = node.cloneNode( false );\r\n\r\n        // Add right-hand siblings to the clone\r\n        while ( offset ) {\r\n            next = offset.nextSibling;\r\n            clone.appendChild( offset );\r\n            offset = next;\r\n        }\r\n\r\n        // Maintain li numbering if inside a quote.\r\n        if ( node.nodeName === 'OL' &&\r\n                getNearest( node, root, 'BLOCKQUOTE' ) ) {\r\n            clone.start = ( +node.start || 1 ) + node.childNodes.length - 1;\r\n        }\r\n\r\n        // DO NOT NORMALISE. This may undo the fixCursor() call\r\n        // of a node lower down the tree!\r\n\r\n        // We need something in the element in order for the cursor to appear.\r\n        fixCursor( node, root );\r\n        fixCursor( clone, root );\r\n\r\n        // Inject clone after original node\r\n        if ( next = node.nextSibling ) {\r\n            parent.insertBefore( clone, next );\r\n        } else {\r\n            parent.appendChild( clone );\r\n        }\r\n\r\n        // Keep on splitting up the tree\r\n        return split( parent, clone, stopNode, root );\r\n    }\r\n    return offset;\r\n}\r\n\r\nfunction _mergeInlines ( node, fakeRange ) {\r\n    var children = node.childNodes,\r\n        l = children.length,\r\n        frags = [],\r\n        child, prev, len;\r\n    while ( l-- ) {\r\n        child = children[l];\r\n        prev = l && children[ l - 1 ];\r\n        if ( l && isInline( child ) && areAlike( child, prev ) &&\r\n                !leafNodeNames[ child.nodeName ] ) {\r\n            if ( fakeRange.startContainer === child ) {\r\n                fakeRange.startContainer = prev;\r\n                fakeRange.startOffset += getLength( prev );\r\n            }\r\n            if ( fakeRange.endContainer === child ) {\r\n                fakeRange.endContainer = prev;\r\n                fakeRange.endOffset += getLength( prev );\r\n            }\r\n            if ( fakeRange.startContainer === node ) {\r\n                if ( fakeRange.startOffset > l ) {\r\n                    fakeRange.startOffset -= 1;\r\n                }\r\n                else if ( fakeRange.startOffset === l ) {\r\n                    fakeRange.startContainer = prev;\r\n                    fakeRange.startOffset = getLength( prev );\r\n                }\r\n            }\r\n            if ( fakeRange.endContainer === node ) {\r\n                if ( fakeRange.endOffset > l ) {\r\n                    fakeRange.endOffset -= 1;\r\n                }\r\n                else if ( fakeRange.endOffset === l ) {\r\n                    fakeRange.endContainer = prev;\r\n                    fakeRange.endOffset = getLength( prev );\r\n                }\r\n            }\r\n            detach( child );\r\n            if ( child.nodeType === TEXT_NODE ) {\r\n                prev.appendData( child.data );\r\n            }\r\n            else {\r\n                frags.push( empty( child ) );\r\n            }\r\n        }\r\n        else if ( child.nodeType === ELEMENT_NODE ) {\r\n            len = frags.length;\r\n            while ( len-- ) {\r\n                child.appendChild( frags.pop() );\r\n            }\r\n            _mergeInlines( child, fakeRange );\r\n        }\r\n    }\r\n}\r\n\r\nfunction mergeInlines ( node, range ) {\r\n    if ( node.nodeType === TEXT_NODE ) {\r\n        node = node.parentNode;\r\n    }\r\n    if ( node.nodeType === ELEMENT_NODE ) {\r\n        var fakeRange = {\r\n            startContainer: range.startContainer,\r\n            startOffset: range.startOffset,\r\n            endContainer: range.endContainer,\r\n            endOffset: range.endOffset\r\n        };\r\n        _mergeInlines( node, fakeRange );\r\n        range.setStart( fakeRange.startContainer, fakeRange.startOffset );\r\n        range.setEnd( fakeRange.endContainer, fakeRange.endOffset );\r\n    }\r\n}\r\n\r\nfunction mergeWithBlock ( block, next, range, root ) {\r\n    var container = next;\r\n    var parent, last, offset;\r\n    while ( ( parent = container.parentNode ) &&\r\n            parent !== root &&\r\n            parent.nodeType === ELEMENT_NODE &&\r\n            parent.childNodes.length === 1 ) {\r\n        container = parent;\r\n    }\r\n    detach( container );\r\n\r\n    offset = block.childNodes.length;\r\n\r\n    // Remove extra <BR> fixer if present.\r\n    last = block.lastChild;\r\n    if ( last && last.nodeName === 'BR' ) {\r\n        block.removeChild( last );\r\n        offset -= 1;\r\n    }\r\n\r\n    block.appendChild( empty( next ) );\r\n\r\n    range.setStart( block, offset );\r\n    range.collapse( true );\r\n    mergeInlines( block, range );\r\n\r\n    // Opera inserts a BR if you delete the last piece of text\r\n    // in a block-level element. Unfortunately, it then gets\r\n    // confused when setting the selection subsequently and\r\n    // refuses to accept the range that finishes just before the\r\n    // BR. Removing the BR fixes the bug.\r\n    // Steps to reproduce bug: Type \"a-b-c\" (where - is return)\r\n    // then backspace twice. The cursor goes to the top instead\r\n    // of after \"b\".\r\n    if ( isPresto && ( last = block.lastChild ) && last.nodeName === 'BR' ) {\r\n        block.removeChild( last );\r\n    }\r\n}\r\n\r\nfunction mergeContainers ( node, root ) {\r\n    var prev = node.previousSibling,\r\n        first = node.firstChild,\r\n        doc = node.ownerDocument,\r\n        isListItem = ( node.nodeName === 'LI' ),\r\n        needsFix, block;\r\n\r\n    // Do not merge LIs, unless it only contains a UL\r\n    if ( isListItem && ( !first || !/^[OU]L$/.test( first.nodeName ) ) ) {\r\n        return;\r\n    }\r\n\r\n    if ( prev && areAlike( prev, node ) ) {\r\n        if ( !isContainer( prev ) ) {\r\n            if ( isListItem ) {\r\n                block = createElement( doc, 'DIV' );\r\n                block.appendChild( empty( prev ) );\r\n                prev.appendChild( block );\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n        detach( node );\r\n        needsFix = !isContainer( node );\r\n        prev.appendChild( empty( node ) );\r\n        if ( needsFix ) {\r\n            fixContainer( prev, root );\r\n        }\r\n        if ( first ) {\r\n            mergeContainers( first, root );\r\n        }\r\n    } else if ( isListItem ) {\r\n        prev = createElement( doc, 'DIV' );\r\n        node.insertBefore( prev, first );\r\n        fixCursor( prev, root );\r\n    }\r\n}\r\n\r\nvar getNodeBefore = function ( node, offset ) {\r\n    var children = node.childNodes;\r\n    while ( offset && node.nodeType === ELEMENT_NODE ) {\r\n        node = children[ offset - 1 ];\r\n        children = node.childNodes;\r\n        offset = children.length;\r\n    }\r\n    return node;\r\n};\r\n\r\nvar getNodeAfter = function ( node, offset ) {\r\n    if ( node.nodeType === ELEMENT_NODE ) {\r\n        var children = node.childNodes;\r\n        if ( offset < children.length ) {\r\n            node = children[ offset ];\r\n        } else {\r\n            while ( node && !node.nextSibling ) {\r\n                node = node.parentNode;\r\n            }\r\n            if ( node ) { node = node.nextSibling; }\r\n        }\r\n    }\r\n    return node;\r\n};\r\n\r\n// ---\r\n\r\nvar insertNodeInRange = function ( range, node ) {\r\n    // Insert at start.\r\n    var startContainer = range.startContainer,\r\n        startOffset = range.startOffset,\r\n        endContainer = range.endContainer,\r\n        endOffset = range.endOffset,\r\n        parent, children, childCount, afterSplit;\r\n\r\n    // If part way through a text node, split it.\r\n    if ( startContainer.nodeType === TEXT_NODE ) {\r\n        parent = startContainer.parentNode;\r\n        children = parent.childNodes;\r\n        if ( startOffset === startContainer.length ) {\r\n            startOffset = indexOf.call( children, startContainer ) + 1;\r\n            if ( range.collapsed ) {\r\n                endContainer = parent;\r\n                endOffset = startOffset;\r\n            }\r\n        } else {\r\n            if ( startOffset ) {\r\n                afterSplit = startContainer.splitText( startOffset );\r\n                if ( endContainer === startContainer ) {\r\n                    endOffset -= startOffset;\r\n                    endContainer = afterSplit;\r\n                }\r\n                else if ( endContainer === parent ) {\r\n                    endOffset += 1;\r\n                }\r\n                startContainer = afterSplit;\r\n            }\r\n            startOffset = indexOf.call( children, startContainer );\r\n        }\r\n        startContainer = parent;\r\n    } else {\r\n        children = startContainer.childNodes;\r\n    }\r\n\r\n    childCount = children.length;\r\n\r\n    if ( startOffset === childCount ) {\r\n        startContainer.appendChild( node );\r\n    } else {\r\n        startContainer.insertBefore( node, children[ startOffset ] );\r\n    }\r\n\r\n    if ( startContainer === endContainer ) {\r\n        endOffset += children.length - childCount;\r\n    }\r\n\r\n    range.setStart( startContainer, startOffset );\r\n    range.setEnd( endContainer, endOffset );\r\n};\r\n\r\nvar extractContentsOfRange = function ( range, common, root ) {\r\n    var startContainer = range.startContainer,\r\n        startOffset = range.startOffset,\r\n        endContainer = range.endContainer,\r\n        endOffset = range.endOffset;\r\n\r\n    if ( !common ) {\r\n        common = range.commonAncestorContainer;\r\n    }\r\n\r\n    if ( common.nodeType === TEXT_NODE ) {\r\n        common = common.parentNode;\r\n    }\r\n\r\n    var endNode = split( endContainer, endOffset, common, root ),\r\n        startNode = split( startContainer, startOffset, common, root ),\r\n        frag = common.ownerDocument.createDocumentFragment(),\r\n        next, before, after;\r\n\r\n    // End node will be null if at end of child nodes list.\r\n    while ( startNode !== endNode ) {\r\n        next = startNode.nextSibling;\r\n        frag.appendChild( startNode );\r\n        startNode = next;\r\n    }\r\n\r\n    startContainer = common;\r\n    startOffset = endNode ?\r\n        indexOf.call( common.childNodes, endNode ) :\r\n        common.childNodes.length;\r\n\r\n    // Merge text nodes if adjacent. IE10 in particular will not focus\r\n    // between two text nodes\r\n    after = common.childNodes[ startOffset ];\r\n    before = after && after.previousSibling;\r\n    if ( before &&\r\n            before.nodeType === TEXT_NODE &&\r\n            after.nodeType === TEXT_NODE ) {\r\n        startContainer = before;\r\n        startOffset = before.length;\r\n        before.appendData( after.data );\r\n        detach( after );\r\n    }\r\n\r\n    range.setStart( startContainer, startOffset );\r\n    range.collapse( true );\r\n\r\n    fixCursor( common, root );\r\n\r\n    return frag;\r\n};\r\n\r\nvar deleteContentsOfRange = function ( range, root ) {\r\n    var startBlock = getStartBlockOfRange( range, root );\r\n    var endBlock = getEndBlockOfRange( range, root );\r\n    var needsMerge = ( startBlock !== endBlock );\r\n    var frag, child;\r\n\r\n    // Move boundaries up as much as possible without exiting block,\r\n    // to reduce need to split.\r\n    moveRangeBoundariesDownTree( range );\r\n    moveRangeBoundariesUpTree( range, startBlock, endBlock, root );\r\n\r\n    // Remove selected range\r\n    frag = extractContentsOfRange( range, null, root );\r\n\r\n    // Move boundaries back down tree as far as possible.\r\n    moveRangeBoundariesDownTree( range );\r\n\r\n    // If we split into two different blocks, merge the blocks.\r\n    if ( needsMerge ) {\r\n        // endBlock will have been split, so need to refetch\r\n        endBlock = getEndBlockOfRange( range, root );\r\n        if ( startBlock && endBlock && startBlock !== endBlock ) {\r\n            mergeWithBlock( startBlock, endBlock, range, root );\r\n        }\r\n    }\r\n\r\n    // Ensure block has necessary children\r\n    if ( startBlock ) {\r\n        fixCursor( startBlock, root );\r\n    }\r\n\r\n    // Ensure root has a block-level element in it.\r\n    child = root.firstChild;\r\n    if ( !child || child.nodeName === 'BR' ) {\r\n        fixCursor( root, root );\r\n        range.selectNodeContents( root.firstChild );\r\n    } else {\r\n        range.collapse( true );\r\n    }\r\n    return frag;\r\n};\r\n\r\n// ---\r\n\r\n// Contents of range will be deleted.\r\n// After method, range will be around inserted content\r\nvar insertTreeFragmentIntoRange = function ( range, frag, root ) {\r\n    var node, block, blockContentsAfterSplit, stopPoint, container, offset;\r\n    var replaceBlock, firstBlockInFrag, nodeAfterSplit, nodeBeforeSplit;\r\n    var tempRange;\r\n\r\n    // Fixup content: ensure no top-level inline, and add cursor fix elements.\r\n    fixContainer( frag, root );\r\n    node = frag;\r\n    while ( ( node = getNextBlock( node, root ) ) ) {\r\n        fixCursor( node, root );\r\n    }\r\n\r\n    // Delete any selected content.\r\n    if ( !range.collapsed ) {\r\n        deleteContentsOfRange( range, root );\r\n    }\r\n\r\n    // Move range down into text nodes.\r\n    moveRangeBoundariesDownTree( range );\r\n    range.collapse( false ); // collapse to end\r\n\r\n    // Where will we split up to? First blockquote parent, otherwise root.\r\n    stopPoint = getNearest( range.endContainer, root, 'BLOCKQUOTE' ) || root;\r\n\r\n    // Merge the contents of the first block in the frag with the focused block.\r\n    // If there are contents in the block after the focus point, collect this\r\n    // up to insert in the last block later. If the block is empty, replace\r\n    // it instead of merging.\r\n    block = getStartBlockOfRange( range, root );\r\n    firstBlockInFrag = getNextBlock( frag, frag );\r\n    replaceBlock = !!block && isEmptyBlock( block );\r\n    if ( block && firstBlockInFrag && !replaceBlock &&\r\n            // Don't merge table cells or PRE elements into block\r\n            !getNearest( firstBlockInFrag, frag, 'PRE' ) &&\r\n            !getNearest( firstBlockInFrag, frag, 'TABLE' ) ) {\r\n        moveRangeBoundariesUpTree( range, block, block, root );\r\n        range.collapse( true ); // collapse to start\r\n        container = range.endContainer;\r\n        offset = range.endOffset;\r\n        // Remove trailing <br> – we don't want this considered content to be\r\n        // inserted again later\r\n        cleanupBRs( block, root, false );\r\n        if ( isInline( container ) ) {\r\n            // Split up to block parent.\r\n            nodeAfterSplit = split(\r\n                container, offset, getPreviousBlock( container, root ), root );\r\n            container = nodeAfterSplit.parentNode;\r\n            offset = indexOf.call( container.childNodes, nodeAfterSplit );\r\n        }\r\n        if ( /*isBlock( container ) && */offset !== getLength( container ) ) {\r\n            // Collect any inline contents of the block after the range point\r\n            blockContentsAfterSplit =\r\n                root.ownerDocument.createDocumentFragment();\r\n            while ( ( node = container.childNodes[ offset ] ) ) {\r\n                blockContentsAfterSplit.appendChild( node );\r\n            }\r\n        }\r\n        // And merge the first block in.\r\n        mergeWithBlock( container, firstBlockInFrag, range, root );\r\n\r\n        // And where we will insert\r\n        offset = indexOf.call( container.parentNode.childNodes, container ) + 1;\r\n        container = container.parentNode;\r\n        range.setEnd( container, offset );\r\n    }\r\n\r\n    // Is there still any content in the fragment?\r\n    if ( getLength( frag ) ) {\r\n        if ( replaceBlock ) {\r\n            range.setEndBefore( block );\r\n            range.collapse( false );\r\n            detach( block );\r\n        }\r\n        moveRangeBoundariesUpTree( range, stopPoint, stopPoint, root );\r\n        // Now split after block up to blockquote (if a parent) or root\r\n        nodeAfterSplit = split(\r\n            range.endContainer, range.endOffset, stopPoint, root );\r\n        nodeBeforeSplit = nodeAfterSplit ?\r\n            nodeAfterSplit.previousSibling :\r\n            stopPoint.lastChild;\r\n        stopPoint.insertBefore( frag, nodeAfterSplit );\r\n        if ( nodeAfterSplit ) {\r\n            range.setEndBefore( nodeAfterSplit );\r\n        } else {\r\n            range.setEnd( stopPoint, getLength( stopPoint ) );\r\n        }\r\n        block = getEndBlockOfRange( range, root );\r\n\r\n        // Get a reference that won't be invalidated if we merge containers.\r\n        moveRangeBoundariesDownTree( range );\r\n        container = range.endContainer;\r\n        offset = range.endOffset;\r\n\r\n        // Merge inserted containers with edges of split\r\n        if ( nodeAfterSplit && isContainer( nodeAfterSplit ) ) {\r\n            mergeContainers( nodeAfterSplit, root );\r\n        }\r\n        nodeAfterSplit = nodeBeforeSplit && nodeBeforeSplit.nextSibling;\r\n        if ( nodeAfterSplit && isContainer( nodeAfterSplit ) ) {\r\n            mergeContainers( nodeAfterSplit, root );\r\n        }\r\n        range.setEnd( container, offset );\r\n    }\r\n\r\n    // Insert inline content saved from before.\r\n    if ( blockContentsAfterSplit ) {\r\n        tempRange = range.cloneRange();\r\n        mergeWithBlock( block, blockContentsAfterSplit, tempRange, root );\r\n        range.setEnd( tempRange.endContainer, tempRange.endOffset );\r\n    }\r\n    moveRangeBoundariesDownTree( range );\r\n};\r\n\r\n// ---\r\n\r\nvar isNodeContainedInRange = function ( range, node, partial ) {\r\n    var nodeRange = node.ownerDocument.createRange();\r\n\r\n    nodeRange.selectNode( node );\r\n\r\n    if ( partial ) {\r\n        // Node must not finish before range starts or start after range\r\n        // finishes.\r\n        var nodeEndBeforeStart = ( range.compareBoundaryPoints(\r\n                END_TO_START, nodeRange ) > -1 ),\r\n            nodeStartAfterEnd = ( range.compareBoundaryPoints(\r\n                START_TO_END, nodeRange ) < 1 );\r\n        return ( !nodeEndBeforeStart && !nodeStartAfterEnd );\r\n    }\r\n    else {\r\n        // Node must start after range starts and finish before range\r\n        // finishes\r\n        var nodeStartAfterStart = ( range.compareBoundaryPoints(\r\n                START_TO_START, nodeRange ) < 1 ),\r\n            nodeEndBeforeEnd = ( range.compareBoundaryPoints(\r\n                END_TO_END, nodeRange ) > -1 );\r\n        return ( nodeStartAfterStart && nodeEndBeforeEnd );\r\n    }\r\n};\r\n\r\nvar moveRangeBoundariesDownTree = function ( range ) {\r\n    var startContainer = range.startContainer,\r\n        startOffset = range.startOffset,\r\n        endContainer = range.endContainer,\r\n        endOffset = range.endOffset,\r\n        maySkipBR = true,\r\n        child;\r\n\r\n    while ( startContainer.nodeType !== TEXT_NODE ) {\r\n        child = startContainer.childNodes[ startOffset ];\r\n        if ( !child || isLeaf( child ) ) {\r\n            break;\r\n        }\r\n        startContainer = child;\r\n        startOffset = 0;\r\n    }\r\n    if ( endOffset ) {\r\n        while ( endContainer.nodeType !== TEXT_NODE ) {\r\n            child = endContainer.childNodes[ endOffset - 1 ];\r\n            if ( !child || isLeaf( child ) ) {\r\n                if ( maySkipBR && child && child.nodeName === 'BR' ) {\r\n                    endOffset -= 1;\r\n                    maySkipBR = false;\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n            endContainer = child;\r\n            endOffset = getLength( endContainer );\r\n        }\r\n    } else {\r\n        while ( endContainer.nodeType !== TEXT_NODE ) {\r\n            child = endContainer.firstChild;\r\n            if ( !child || isLeaf( child ) ) {\r\n                break;\r\n            }\r\n            endContainer = child;\r\n        }\r\n    }\r\n\r\n    // If collapsed, this algorithm finds the nearest text node positions\r\n    // *outside* the range rather than inside, but also it flips which is\r\n    // assigned to which.\r\n    if ( range.collapsed ) {\r\n        range.setStart( endContainer, endOffset );\r\n        range.setEnd( startContainer, startOffset );\r\n    } else {\r\n        range.setStart( startContainer, startOffset );\r\n        range.setEnd( endContainer, endOffset );\r\n    }\r\n};\r\n\r\nvar moveRangeBoundariesUpTree = function ( range, startMax, endMax, root ) {\r\n    var startContainer = range.startContainer;\r\n    var startOffset = range.startOffset;\r\n    var endContainer = range.endContainer;\r\n    var endOffset = range.endOffset;\r\n    var maySkipBR = true;\r\n    var parent;\r\n\r\n    if ( !startMax ) {\r\n        startMax = range.commonAncestorContainer;\r\n    }\r\n    if ( !endMax ) {\r\n        endMax = startMax;\r\n    }\r\n\r\n    while ( !startOffset &&\r\n            startContainer !== startMax &&\r\n            startContainer !== root ) {\r\n        parent = startContainer.parentNode;\r\n        startOffset = indexOf.call( parent.childNodes, startContainer );\r\n        startContainer = parent;\r\n    }\r\n\r\n    while ( true ) {\r\n        if ( maySkipBR &&\r\n                endContainer.nodeType !== TEXT_NODE &&\r\n                endContainer.childNodes[ endOffset ] &&\r\n                endContainer.childNodes[ endOffset ].nodeName === 'BR' ) {\r\n            endOffset += 1;\r\n            maySkipBR = false;\r\n        }\r\n        if ( endContainer === endMax ||\r\n                endContainer === root ||\r\n                endOffset !== getLength( endContainer ) ) {\r\n            break;\r\n        }\r\n        parent = endContainer.parentNode;\r\n        endOffset = indexOf.call( parent.childNodes, endContainer ) + 1;\r\n        endContainer = parent;\r\n    }\r\n\r\n    range.setStart( startContainer, startOffset );\r\n    range.setEnd( endContainer, endOffset );\r\n};\r\n\r\n// Returns the first block at least partially contained by the range,\r\n// or null if no block is contained by the range.\r\nvar getStartBlockOfRange = function ( range, root ) {\r\n    var container = range.startContainer,\r\n        block;\r\n\r\n    // If inline, get the containing block.\r\n    if ( isInline( container ) ) {\r\n        block = getPreviousBlock( container, root );\r\n    } else if ( container !== root && isBlock( container ) ) {\r\n        block = container;\r\n    } else {\r\n        block = getNodeBefore( container, range.startOffset );\r\n        block = getNextBlock( block, root );\r\n    }\r\n    // Check the block actually intersects the range\r\n    return block && isNodeContainedInRange( range, block, true ) ? block : null;\r\n};\r\n\r\n// Returns the last block at least partially contained by the range,\r\n// or null if no block is contained by the range.\r\nvar getEndBlockOfRange = function ( range, root ) {\r\n    var container = range.endContainer,\r\n        block, child;\r\n\r\n    // If inline, get the containing block.\r\n    if ( isInline( container ) ) {\r\n        block = getPreviousBlock( container, root );\r\n    } else if ( container !== root && isBlock( container ) ) {\r\n        block = container;\r\n    } else {\r\n        block = getNodeAfter( container, range.endOffset );\r\n        if ( !block || !isOrContains( root, block ) ) {\r\n            block = root;\r\n            while ( child = block.lastChild ) {\r\n                block = child;\r\n            }\r\n        }\r\n        block = getPreviousBlock( block, root );\r\n    }\r\n    // Check the block actually intersects the range\r\n    return block && isNodeContainedInRange( range, block, true ) ? block : null;\r\n};\r\n\r\nvar contentWalker = new TreeWalker( null,\r\n    SHOW_TEXT|SHOW_ELEMENT,\r\n    function ( node ) {\r\n        return node.nodeType === TEXT_NODE ?\r\n            notWS.test( node.data ) :\r\n            node.nodeName === 'IMG';\r\n    }\r\n);\r\n\r\nvar rangeDoesStartAtBlockBoundary = function ( range, root ) {\r\n    var startContainer = range.startContainer;\r\n    var startOffset = range.startOffset;\r\n    var nodeAfterCursor;\r\n\r\n    // If in the middle or end of a text node, we're not at the boundary.\r\n    contentWalker.root = null;\r\n    if ( startContainer.nodeType === TEXT_NODE ) {\r\n        if ( startOffset ) {\r\n            return false;\r\n        }\r\n        nodeAfterCursor = startContainer;\r\n    } else {\r\n        nodeAfterCursor = getNodeAfter( startContainer, startOffset );\r\n        if ( nodeAfterCursor && !isOrContains( root, nodeAfterCursor ) ) {\r\n            nodeAfterCursor = null;\r\n        }\r\n        // The cursor was right at the end of the document\r\n        if ( !nodeAfterCursor ) {\r\n            nodeAfterCursor = getNodeBefore( startContainer, startOffset );\r\n            if ( nodeAfterCursor.nodeType === TEXT_NODE &&\r\n                    nodeAfterCursor.length ) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Otherwise, look for any previous content in the same block.\r\n    contentWalker.currentNode = nodeAfterCursor;\r\n    contentWalker.root = getStartBlockOfRange( range, root );\r\n\r\n    return !contentWalker.previousNode();\r\n};\r\n\r\nvar rangeDoesEndAtBlockBoundary = function ( range, root ) {\r\n    var endContainer = range.endContainer,\r\n        endOffset = range.endOffset,\r\n        length;\r\n\r\n    // If in a text node with content, and not at the end, we're not\r\n    // at the boundary\r\n    contentWalker.root = null;\r\n    if ( endContainer.nodeType === TEXT_NODE ) {\r\n        length = endContainer.data.length;\r\n        if ( length && endOffset < length ) {\r\n            return false;\r\n        }\r\n        contentWalker.currentNode = endContainer;\r\n    } else {\r\n        contentWalker.currentNode = getNodeBefore( endContainer, endOffset );\r\n    }\r\n\r\n    // Otherwise, look for any further content in the same block.\r\n    contentWalker.root = getEndBlockOfRange( range, root );\r\n\r\n    return !contentWalker.nextNode();\r\n};\r\n\r\nvar expandRangeToBlockBoundaries = function ( range, root ) {\r\n    var start = getStartBlockOfRange( range, root ),\r\n        end = getEndBlockOfRange( range, root ),\r\n        parent;\r\n\r\n    if ( start && end ) {\r\n        parent = start.parentNode;\r\n        range.setStart( parent, indexOf.call( parent.childNodes, start ) );\r\n        parent = end.parentNode;\r\n        range.setEnd( parent, indexOf.call( parent.childNodes, end ) + 1 );\r\n    }\r\n};\r\n\r\nvar keys = {\r\n    8: 'backspace',\r\n    9: 'tab',\r\n    13: 'enter',\r\n    32: 'space',\r\n    33: 'pageup',\r\n    34: 'pagedown',\r\n    37: 'left',\r\n    39: 'right',\r\n    46: 'delete',\r\n    219: '[',\r\n    221: ']'\r\n};\r\n\r\n// Ref: http://unixpapa.com/js/key.html\r\nvar onKey = function ( event ) {\r\n    var code = event.keyCode,\r\n        key = keys[ code ],\r\n        modifiers = '',\r\n        range = this.getSelection();\r\n\r\n    if ( event.defaultPrevented ) {\r\n        return;\r\n    }\r\n\r\n    if ( !key ) {\r\n        key = String.fromCharCode( code ).toLowerCase();\r\n        // Only reliable for letters and numbers\r\n        if ( !/^[A-Za-z0-9]$/.test( key ) ) {\r\n            key = '';\r\n        }\r\n    }\r\n\r\n    // On keypress, delete and '.' both have event.keyCode 46\r\n    // Must check event.which to differentiate.\r\n    if ( isPresto && event.which === 46 ) {\r\n        key = '.';\r\n    }\r\n\r\n    // Function keys\r\n    if ( 111 < code && code < 124 ) {\r\n        key = 'f' + ( code - 111 );\r\n    }\r\n\r\n    // We need to apply the backspace/delete handlers regardless of\r\n    // control key modifiers.\r\n    if ( key !== 'backspace' && key !== 'delete' ) {\r\n        if ( event.altKey  ) { modifiers += 'alt-'; }\r\n        if ( event.ctrlKey ) { modifiers += 'ctrl-'; }\r\n        if ( event.metaKey ) { modifiers += 'meta-'; }\r\n    }\r\n    // However, on Windows, shift-delete is apparently \"cut\" (WTF right?), so\r\n    // we want to let the browser handle shift-delete.\r\n    if ( event.shiftKey ) { modifiers += 'shift-'; }\r\n\r\n    key = modifiers + key;\r\n\r\n    if ( this._keyHandlers[ key ] ) {\r\n        this._keyHandlers[ key ]( this, event, range );\r\n    } else if ( key.length === 1 && !range.collapsed ) {\r\n        // Record undo checkpoint.\r\n        this.saveUndoState( range );\r\n        // Delete the selection\r\n        deleteContentsOfRange( range, this._root );\r\n        this._ensureBottomLine();\r\n        this.setSelection( range );\r\n        this._updatePath( range, true );\r\n    }\r\n};\r\n\r\nvar mapKeyTo = function ( method ) {\r\n    return function ( self, event ) {\r\n        event.preventDefault();\r\n        self[ method ]();\r\n    };\r\n};\r\n\r\nvar mapKeyToFormat = function ( tag, remove ) {\r\n    remove = remove || null;\r\n    return function ( self, event ) {\r\n        event.preventDefault();\r\n        var range = self.getSelection();\r\n        if ( self.hasFormat( tag, null, range ) ) {\r\n            self.changeFormat( null, { tag: tag }, range );\r\n        } else {\r\n            self.changeFormat( { tag: tag }, remove, range );\r\n        }\r\n    };\r\n};\r\n\r\n// If you delete the content inside a span with a font styling, Webkit will\r\n// replace it with a <font> tag (!). If you delete all the text inside a\r\n// link in Opera, it won't delete the link. Let's make things consistent. If\r\n// you delete all text inside an inline tag, remove the inline tag.\r\nvar afterDelete = function ( self, range ) {\r\n    try {\r\n        if ( !range ) { range = self.getSelection(); }\r\n        var node = range.startContainer,\r\n            parent;\r\n        // Climb the tree from the focus point while we are inside an empty\r\n        // inline element\r\n        if ( node.nodeType === TEXT_NODE ) {\r\n            node = node.parentNode;\r\n        }\r\n        parent = node;\r\n        while ( isInline( parent ) &&\r\n                ( !parent.textContent || parent.textContent === ZWS ) ) {\r\n            node = parent;\r\n            parent = node.parentNode;\r\n        }\r\n        // If focused in empty inline element\r\n        if ( node !== parent ) {\r\n            // Move focus to just before empty inline(s)\r\n            range.setStart( parent,\r\n                indexOf.call( parent.childNodes, node ) );\r\n            range.collapse( true );\r\n            // Remove empty inline(s)\r\n            parent.removeChild( node );\r\n            // Fix cursor in block\r\n            if ( !isBlock( parent ) ) {\r\n                parent = getPreviousBlock( parent, self._root );\r\n            }\r\n            fixCursor( parent, self._root );\r\n            // Move cursor into text node\r\n            moveRangeBoundariesDownTree( range );\r\n        }\r\n        // If you delete the last character in the sole <div> in Chrome,\r\n        // it removes the div and replaces it with just a <br> inside the\r\n        // root. Detach the <br>; the _ensureBottomLine call will insert a new\r\n        // block.\r\n        if ( node === self._root &&\r\n                ( node = node.firstChild ) && node.nodeName === 'BR' ) {\r\n            detach( node );\r\n        }\r\n        self._ensureBottomLine();\r\n        self.setSelection( range );\r\n        self._updatePath( range, true );\r\n    } catch ( error ) {\r\n        self.didError( error );\r\n    }\r\n};\r\n\r\nvar keyHandlers = {\r\n    enter: function ( self, event, range ) {\r\n        var root = self._root;\r\n        var block, parent, nodeAfterSplit;\r\n\r\n        // We handle this ourselves\r\n        event.preventDefault();\r\n\r\n        // Save undo checkpoint and add any links in the preceding section.\r\n        // Remove any zws so we don't think there's content in an empty\r\n        // block.\r\n        self._recordUndoState( range );\r\n        addLinks( range.startContainer, root, self );\r\n        self._removeZWS();\r\n        self._getRangeAndRemoveBookmark( range );\r\n\r\n        // Selected text is overwritten, therefore delete the contents\r\n        // to collapse selection.\r\n        if ( !range.collapsed ) {\r\n            deleteContentsOfRange( range, root );\r\n        }\r\n\r\n        block = getStartBlockOfRange( range, root );\r\n\r\n        // If this is a malformed bit of document or in a table;\r\n        // just play it safe and insert a <br>.\r\n        if ( !block || /^T[HD]$/.test( block.nodeName ) ) {\r\n            // If inside an <a>, move focus out\r\n            parent = getNearest( range.endContainer, root, 'A' );\r\n            if ( parent ) {\r\n                parent = parent.parentNode;\r\n                moveRangeBoundariesUpTree( range, parent, parent, root );\r\n                range.collapse( false );\r\n            }\r\n            insertNodeInRange( range, self.createElement( 'BR' ) );\r\n            range.collapse( false );\r\n            self.setSelection( range );\r\n            self._updatePath( range, true );\r\n            return;\r\n        }\r\n\r\n        // If in a list, we'll split the LI instead.\r\n        if ( parent = getNearest( block, root, 'LI' ) ) {\r\n            block = parent;\r\n        }\r\n\r\n        if ( isEmptyBlock( block ) ) {\r\n            // Break list\r\n            if ( getNearest( block, root, 'UL' ) ||\r\n                    getNearest( block, root, 'OL' ) ) {\r\n                return self.decreaseListLevel( range );\r\n            }\r\n            // Break blockquote\r\n            else if ( getNearest( block, root, 'BLOCKQUOTE' ) ) {\r\n                return self.modifyBlocks( removeBlockQuote, range );\r\n            }\r\n        }\r\n\r\n        // Otherwise, split at cursor point.\r\n        nodeAfterSplit = splitBlock( self, block,\r\n            range.startContainer, range.startOffset );\r\n\r\n        // Clean up any empty inlines if we hit enter at the beginning of the\r\n        // block\r\n        removeZWS( block );\r\n        removeEmptyInlines( block );\r\n        fixCursor( block, root );\r\n\r\n        // Focus cursor\r\n        // If there's a <b>/<i> etc. at the beginning of the split\r\n        // make sure we focus inside it.\r\n        while ( nodeAfterSplit.nodeType === ELEMENT_NODE ) {\r\n            var child = nodeAfterSplit.firstChild,\r\n                next;\r\n\r\n            // Don't continue links over a block break; unlikely to be the\r\n            // desired outcome.\r\n            if ( nodeAfterSplit.nodeName === 'A' &&\r\n                    ( !nodeAfterSplit.textContent ||\r\n                        nodeAfterSplit.textContent === ZWS ) ) {\r\n                child = self._doc.createTextNode( '' );\r\n                replaceWith( nodeAfterSplit, child );\r\n                nodeAfterSplit = child;\r\n                break;\r\n            }\r\n\r\n            while ( child && child.nodeType === TEXT_NODE && !child.data ) {\r\n                next = child.nextSibling;\r\n                if ( !next || next.nodeName === 'BR' ) {\r\n                    break;\r\n                }\r\n                detach( child );\r\n                child = next;\r\n            }\r\n\r\n            // 'BR's essentially don't count; they're a browser hack.\r\n            // If you try to select the contents of a 'BR', FF will not let\r\n            // you type anything!\r\n            if ( !child || child.nodeName === 'BR' ||\r\n                    ( child.nodeType === TEXT_NODE && !isPresto ) ) {\r\n                break;\r\n            }\r\n            nodeAfterSplit = child;\r\n        }\r\n        range = self._createRange( nodeAfterSplit, 0 );\r\n        self.setSelection( range );\r\n        self._updatePath( range, true );\r\n    },\r\n    backspace: function ( self, event, range ) {\r\n        var root = self._root;\r\n        self._removeZWS();\r\n        // Record undo checkpoint.\r\n        self.saveUndoState( range );\r\n        // If not collapsed, delete contents\r\n        if ( !range.collapsed ) {\r\n            event.preventDefault();\r\n            deleteContentsOfRange( range, root );\r\n            afterDelete( self, range );\r\n        }\r\n        // If at beginning of block, merge with previous\r\n        else if ( rangeDoesStartAtBlockBoundary( range, root ) ) {\r\n            event.preventDefault();\r\n            var current = getStartBlockOfRange( range, root );\r\n            var previous;\r\n            if ( !current ) {\r\n                return;\r\n            }\r\n            // In case inline data has somehow got between blocks.\r\n            fixContainer( current.parentNode, root );\r\n            // Now get previous block\r\n            previous = getPreviousBlock( current, root );\r\n            // Must not be at the very beginning of the text area.\r\n            if ( previous ) {\r\n                // If not editable, just delete whole block.\r\n                if ( !previous.isContentEditable ) {\r\n                    detach( previous );\r\n                    return;\r\n                }\r\n                // Otherwise merge.\r\n                mergeWithBlock( previous, current, range, root );\r\n                // If deleted line between containers, merge newly adjacent\r\n                // containers.\r\n                current = previous.parentNode;\r\n                while ( current !== root && !current.nextSibling ) {\r\n                    current = current.parentNode;\r\n                }\r\n                if ( current !== root && ( current = current.nextSibling ) ) {\r\n                    mergeContainers( current, root );\r\n                }\r\n                self.setSelection( range );\r\n            }\r\n            // If at very beginning of text area, allow backspace\r\n            // to break lists/blockquote.\r\n            else if ( current ) {\r\n                // Break list\r\n                if ( getNearest( current, root, 'UL' ) ||\r\n                        getNearest( current, root, 'OL' ) ) {\r\n                    return self.decreaseListLevel( range );\r\n                }\r\n                // Break blockquote\r\n                else if ( getNearest( current, root, 'BLOCKQUOTE' ) ) {\r\n                    return self.modifyBlocks( decreaseBlockQuoteLevel, range );\r\n                }\r\n                self.setSelection( range );\r\n                self._updatePath( range, true );\r\n            }\r\n        }\r\n        // Otherwise, leave to browser but check afterwards whether it has\r\n        // left behind an empty inline tag.\r\n        else {\r\n            self.setSelection( range );\r\n            setTimeout( function () { afterDelete( self ); }, 0 );\r\n        }\r\n    },\r\n    'delete': function ( self, event, range ) {\r\n        var root = self._root;\r\n        var current, next, originalRange,\r\n            cursorContainer, cursorOffset, nodeAfterCursor;\r\n        self._removeZWS();\r\n        // Record undo checkpoint.\r\n        self.saveUndoState( range );\r\n        // If not collapsed, delete contents\r\n        if ( !range.collapsed ) {\r\n            event.preventDefault();\r\n            deleteContentsOfRange( range, root );\r\n            afterDelete( self, range );\r\n        }\r\n        // If at end of block, merge next into this block\r\n        else if ( rangeDoesEndAtBlockBoundary( range, root ) ) {\r\n            event.preventDefault();\r\n            current = getStartBlockOfRange( range, root );\r\n            if ( !current ) {\r\n                return;\r\n            }\r\n            // In case inline data has somehow got between blocks.\r\n            fixContainer( current.parentNode, root );\r\n            // Now get next block\r\n            next = getNextBlock( current, root );\r\n            // Must not be at the very end of the text area.\r\n            if ( next ) {\r\n                // If not editable, just delete whole block.\r\n                if ( !next.isContentEditable ) {\r\n                    detach( next );\r\n                    return;\r\n                }\r\n                // Otherwise merge.\r\n                mergeWithBlock( current, next, range, root );\r\n                // If deleted line between containers, merge newly adjacent\r\n                // containers.\r\n                next = current.parentNode;\r\n                while ( next !== root && !next.nextSibling ) {\r\n                    next = next.parentNode;\r\n                }\r\n                if ( next !== root && ( next = next.nextSibling ) ) {\r\n                    mergeContainers( next, root );\r\n                }\r\n                self.setSelection( range );\r\n                self._updatePath( range, true );\r\n            }\r\n        }\r\n        // Otherwise, leave to browser but check afterwards whether it has\r\n        // left behind an empty inline tag.\r\n        else {\r\n            // But first check if the cursor is just before an IMG tag. If so,\r\n            // delete it ourselves, because the browser won't if it is not\r\n            // inline.\r\n            originalRange = range.cloneRange();\r\n            moveRangeBoundariesUpTree( range, root, root, root );\r\n            cursorContainer = range.endContainer;\r\n            cursorOffset = range.endOffset;\r\n            if ( cursorContainer.nodeType === ELEMENT_NODE ) {\r\n                nodeAfterCursor = cursorContainer.childNodes[ cursorOffset ];\r\n                if ( nodeAfterCursor && nodeAfterCursor.nodeName === 'IMG' ) {\r\n                    event.preventDefault();\r\n                    detach( nodeAfterCursor );\r\n                    moveRangeBoundariesDownTree( range );\r\n                    afterDelete( self, range );\r\n                    return;\r\n                }\r\n            }\r\n            self.setSelection( originalRange );\r\n            setTimeout( function () { afterDelete( self ); }, 0 );\r\n        }\r\n    },\r\n    tab: function ( self, event, range ) {\r\n        var root = self._root;\r\n        var node, parent;\r\n        self._removeZWS();\r\n        // If no selection and at start of block\r\n        if ( range.collapsed && rangeDoesStartAtBlockBoundary( range, root ) ) {\r\n            node = getStartBlockOfRange( range, root );\r\n            // Iterate through the block's parents\r\n            while ( ( parent = node.parentNode ) ) {\r\n                // If we find a UL or OL (so are in a list, node must be an LI)\r\n                if ( parent.nodeName === 'UL' || parent.nodeName === 'OL' ) {\r\n                    // Then increase the list level\r\n                    event.preventDefault();\r\n                    self.increaseListLevel( range );\r\n                    break;\r\n                }\r\n                node = parent;\r\n            }\r\n        }\r\n    },\r\n    'shift-tab': function ( self, event, range ) {\r\n        var root = self._root;\r\n        var node;\r\n        self._removeZWS();\r\n        // If no selection and at start of block\r\n        if ( range.collapsed && rangeDoesStartAtBlockBoundary( range, root ) ) {\r\n            // Break list\r\n            node = range.startContainer;\r\n            if ( getNearest( node, root, 'UL' ) ||\r\n                    getNearest( node, root, 'OL' ) ) {\r\n                event.preventDefault();\r\n                self.decreaseListLevel( range );\r\n            }\r\n        }\r\n    },\r\n    space: function ( self, _, range ) {\r\n        var node, parent;\r\n        self._recordUndoState( range );\r\n        addLinks( range.startContainer, self._root, self );\r\n        self._getRangeAndRemoveBookmark( range );\r\n\r\n        // If the cursor is at the end of a link (<a>foo|</a>) then move it\r\n        // outside of the link (<a>foo</a>|) so that the space is not part of\r\n        // the link text.\r\n        node = range.endContainer;\r\n        parent = node.parentNode;\r\n        if ( range.collapsed && parent.nodeName === 'A' &&\r\n                !node.nextSibling && range.endOffset === getLength( node ) ) {\r\n            range.setStartAfter( parent );\r\n        }\r\n        // Delete the selection if not collapsed\r\n        else if ( !range.collapsed ) {\r\n            deleteContentsOfRange( range, self._root );\r\n            self._ensureBottomLine();\r\n            self.setSelection( range );\r\n            self._updatePath( range, true );\r\n        }\r\n\r\n        self.setSelection( range );\r\n    },\r\n    left: function ( self ) {\r\n        self._removeZWS();\r\n    },\r\n    right: function ( self ) {\r\n        self._removeZWS();\r\n    }\r\n};\r\n\r\n// Firefox pre v29 incorrectly handles Cmd-left/Cmd-right on Mac:\r\n// it goes back/forward in history! Override to do the right\r\n// thing.\r\n// https://bugzilla.mozilla.org/show_bug.cgi?id=289384\r\nif ( isMac && isGecko ) {\r\n    keyHandlers[ 'meta-left' ] = function ( self, event ) {\r\n        event.preventDefault();\r\n        var sel = getWindowSelection( self );\r\n        if ( sel && sel.modify ) {\r\n            sel.modify( 'move', 'backward', 'lineboundary' );\r\n        }\r\n    };\r\n    keyHandlers[ 'meta-right' ] = function ( self, event ) {\r\n        event.preventDefault();\r\n        var sel = getWindowSelection( self );\r\n        if ( sel && sel.modify ) {\r\n            sel.modify( 'move', 'forward', 'lineboundary' );\r\n        }\r\n    };\r\n}\r\n\r\n// System standard for page up/down on Mac is to just scroll, not move the\r\n// cursor. On Linux/Windows, it should move the cursor, but some browsers don't\r\n// implement this natively. Override to support it.\r\nif ( !isMac ) {\r\n    keyHandlers.pageup = function ( self ) {\r\n        self.moveCursorToStart();\r\n    };\r\n    keyHandlers.pagedown = function ( self ) {\r\n        self.moveCursorToEnd();\r\n    };\r\n}\r\n\r\nkeyHandlers[ ctrlKey + 'b' ] = mapKeyToFormat( 'B' );\r\nkeyHandlers[ ctrlKey + 'i' ] = mapKeyToFormat( 'I' );\r\nkeyHandlers[ ctrlKey + 'u' ] = mapKeyToFormat( 'U' );\r\nkeyHandlers[ ctrlKey + 'shift-7' ] = mapKeyToFormat( 'S' );\r\nkeyHandlers[ ctrlKey + 'shift-5' ] = mapKeyToFormat( 'SUB', { tag: 'SUP' } );\r\nkeyHandlers[ ctrlKey + 'shift-6' ] = mapKeyToFormat( 'SUP', { tag: 'SUB' } );\r\nkeyHandlers[ ctrlKey + 'shift-8' ] = mapKeyTo( 'makeUnorderedList' );\r\nkeyHandlers[ ctrlKey + 'shift-9' ] = mapKeyTo( 'makeOrderedList' );\r\nkeyHandlers[ ctrlKey + '[' ] = mapKeyTo( 'decreaseQuoteLevel' );\r\nkeyHandlers[ ctrlKey + ']' ] = mapKeyTo( 'increaseQuoteLevel' );\r\nkeyHandlers[ ctrlKey + 'y' ] = mapKeyTo( 'redo' );\r\nkeyHandlers[ ctrlKey + 'z' ] = mapKeyTo( 'undo' );\r\nkeyHandlers[ ctrlKey + 'shift-z' ] = mapKeyTo( 'redo' );\r\n\r\nvar fontSizes = {\r\n    1: 10,\r\n    2: 13,\r\n    3: 16,\r\n    4: 18,\r\n    5: 24,\r\n    6: 32,\r\n    7: 48\r\n};\r\n\r\nvar styleToSemantic = {\r\n    backgroundColor: {\r\n        regexp: notWS,\r\n        replace: function ( doc, colour ) {\r\n            return createElement( doc, 'SPAN', {\r\n                'class': HIGHLIGHT_CLASS,\r\n                style: 'background-color:' + colour\r\n            });\r\n        }\r\n    },\r\n    color: {\r\n        regexp: notWS,\r\n        replace: function ( doc, colour ) {\r\n            return createElement( doc, 'SPAN', {\r\n                'class': COLOUR_CLASS,\r\n                style: 'color:' + colour\r\n            });\r\n        }\r\n    },\r\n    fontWeight: {\r\n        regexp: /^bold|^700/i,\r\n        replace: function ( doc ) {\r\n            return createElement( doc, 'B' );\r\n        }\r\n    },\r\n    fontStyle: {\r\n        regexp: /^italic/i,\r\n        replace: function ( doc ) {\r\n            return createElement( doc, 'I' );\r\n        }\r\n    },\r\n    fontFamily: {\r\n        regexp: notWS,\r\n        replace: function ( doc, family ) {\r\n            return createElement( doc, 'SPAN', {\r\n                'class': FONT_FAMILY_CLASS,\r\n                style: 'font-family:' + family\r\n            });\r\n        }\r\n    },\r\n    fontSize: {\r\n        regexp: notWS,\r\n        replace: function ( doc, size ) {\r\n            return createElement( doc, 'SPAN', {\r\n                'class': FONT_SIZE_CLASS,\r\n                style: 'font-size:' + size\r\n            });\r\n        }\r\n    },\r\n    textDecoration: {\r\n        regexp: /^underline/i,\r\n        replace: function ( doc ) {\r\n            return createElement( doc, 'U' );\r\n        }\r\n    }\r\n};\r\n\r\nvar replaceWithTag = function ( tag ) {\r\n    return function ( node, parent ) {\r\n        var el = createElement( node.ownerDocument, tag );\r\n        parent.replaceChild( el, node );\r\n        el.appendChild( empty( node ) );\r\n        return el;\r\n    };\r\n};\r\n\r\nvar replaceStyles = function ( node, parent ) {\r\n    var style = node.style;\r\n    var doc = node.ownerDocument;\r\n    var attr, converter, css, newTreeBottom, newTreeTop, el;\r\n\r\n    for ( attr in styleToSemantic ) {\r\n        converter = styleToSemantic[ attr ];\r\n        css = style[ attr ];\r\n        if ( css && converter.regexp.test( css ) ) {\r\n            el = converter.replace( doc, css );\r\n            if ( !newTreeTop ) {\r\n                newTreeTop = el;\r\n            }\r\n            if ( newTreeBottom ) {\r\n                newTreeBottom.appendChild( el );\r\n            }\r\n            newTreeBottom = el;\r\n            node.style[ attr ] = '';\r\n        }\r\n    }\r\n\r\n    if ( newTreeTop ) {\r\n        newTreeBottom.appendChild( empty( node ) );\r\n        if ( node.nodeName === 'SPAN' ) {\r\n            parent.replaceChild( newTreeTop, node );\r\n        } else {\r\n            node.appendChild( newTreeTop );\r\n        }\r\n    }\r\n\r\n    return newTreeBottom || node;\r\n};\r\n\r\nvar stylesRewriters = {\r\n    P: replaceStyles,\r\n    SPAN: replaceStyles,\r\n    STRONG: replaceWithTag( 'B' ),\r\n    EM: replaceWithTag( 'I' ),\r\n    INS: replaceWithTag( 'U' ),\r\n    STRIKE: replaceWithTag( 'S' ),\r\n    FONT: function ( node, parent ) {\r\n        var face = node.face,\r\n            size = node.size,\r\n            colour = node.color,\r\n            doc = node.ownerDocument,\r\n            fontSpan, sizeSpan, colourSpan,\r\n            newTreeBottom, newTreeTop;\r\n        if ( face ) {\r\n            fontSpan = createElement( doc, 'SPAN', {\r\n                'class': FONT_FAMILY_CLASS,\r\n                style: 'font-family:' + face\r\n            });\r\n            newTreeTop = fontSpan;\r\n            newTreeBottom = fontSpan;\r\n        }\r\n        if ( size ) {\r\n            sizeSpan = createElement( doc, 'SPAN', {\r\n                'class': FONT_SIZE_CLASS,\r\n                style: 'font-size:' + fontSizes[ size ] + 'px'\r\n            });\r\n            if ( !newTreeTop ) {\r\n                newTreeTop = sizeSpan;\r\n            }\r\n            if ( newTreeBottom ) {\r\n                newTreeBottom.appendChild( sizeSpan );\r\n            }\r\n            newTreeBottom = sizeSpan;\r\n        }\r\n        if ( colour && /^#?([\\dA-F]{3}){1,2}$/i.test( colour ) ) {\r\n            if ( colour.charAt( 0 ) !== '#' ) {\r\n                colour = '#' + colour;\r\n            }\r\n            colourSpan = createElement( doc, 'SPAN', {\r\n                'class': COLOUR_CLASS,\r\n                style: 'color:' + colour\r\n            });\r\n            if ( !newTreeTop ) {\r\n                newTreeTop = colourSpan;\r\n            }\r\n            if ( newTreeBottom ) {\r\n                newTreeBottom.appendChild( colourSpan );\r\n            }\r\n            newTreeBottom = colourSpan;\r\n        }\r\n        if ( !newTreeTop ) {\r\n            newTreeTop = newTreeBottom = createElement( doc, 'SPAN' );\r\n        }\r\n        parent.replaceChild( newTreeTop, node );\r\n        newTreeBottom.appendChild( empty( node ) );\r\n        return newTreeBottom;\r\n    },\r\n    TT: function ( node, parent ) {\r\n        var el = createElement( node.ownerDocument, 'SPAN', {\r\n            'class': FONT_FAMILY_CLASS,\r\n            style: 'font-family:menlo,consolas,\"courier new\",monospace'\r\n        });\r\n        parent.replaceChild( el, node );\r\n        el.appendChild( empty( node ) );\r\n        return el;\r\n    }\r\n};\r\n\r\nvar allowedBlock = /^(?:A(?:DDRESS|RTICLE|SIDE|UDIO)|BLOCKQUOTE|CAPTION|D(?:[DLT]|IV)|F(?:IGURE|IGCAPTION|OOTER)|H[1-6]|HEADER|L(?:ABEL|EGEND|I)|O(?:L|UTPUT)|P(?:RE)?|SECTION|T(?:ABLE|BODY|D|FOOT|H|HEAD|R)|COL(?:GROUP)?|UL)$/;\r\n\r\nvar blacklist = /^(?:HEAD|META|STYLE)/;\r\n\r\nvar walker = new TreeWalker( null, SHOW_TEXT|SHOW_ELEMENT, function () {\r\n    return true;\r\n});\r\n\r\n/*\r\n    Two purposes:\r\n\r\n    1. Remove nodes we don't want, such as weird <o:p> tags, comment nodes\r\n       and whitespace nodes.\r\n    2. Convert inline tags into our preferred format.\r\n*/\r\nvar cleanTree = function cleanTree ( node, preserveWS ) {\r\n    var children = node.childNodes,\r\n        nonInlineParent, i, l, child, nodeName, nodeType, rewriter, childLength,\r\n        startsWithWS, endsWithWS, data, sibling;\r\n\r\n    nonInlineParent = node;\r\n    while ( isInline( nonInlineParent ) ) {\r\n        nonInlineParent = nonInlineParent.parentNode;\r\n    }\r\n    walker.root = nonInlineParent;\r\n\r\n    for ( i = 0, l = children.length; i < l; i += 1 ) {\r\n        child = children[i];\r\n        nodeName = child.nodeName;\r\n        nodeType = child.nodeType;\r\n        rewriter = stylesRewriters[ nodeName ];\r\n        if ( nodeType === ELEMENT_NODE ) {\r\n            childLength = child.childNodes.length;\r\n            if ( rewriter ) {\r\n                child = rewriter( child, node );\r\n            } else if ( blacklist.test( nodeName ) ) {\r\n                node.removeChild( child );\r\n                i -= 1;\r\n                l -= 1;\r\n                continue;\r\n            } else if ( !allowedBlock.test( nodeName ) && !isInline( child ) ) {\r\n                i -= 1;\r\n                l += childLength - 1;\r\n                node.replaceChild( empty( child ), child );\r\n                continue;\r\n            }\r\n            if ( childLength ) {\r\n                cleanTree( child, preserveWS || ( nodeName === 'PRE' ) );\r\n            }\r\n        } else {\r\n            if ( nodeType === TEXT_NODE ) {\r\n                data = child.data;\r\n                startsWithWS = !notWS.test( data.charAt( 0 ) );\r\n                endsWithWS = !notWS.test( data.charAt( data.length - 1 ) );\r\n                if ( preserveWS || ( !startsWithWS && !endsWithWS ) ) {\r\n                    continue;\r\n                }\r\n                // Iterate through the nodes; if we hit some other content\r\n                // before the start of a new block we don't trim\r\n                if ( startsWithWS ) {\r\n                    walker.currentNode = child;\r\n                    while ( sibling = walker.previousPONode() ) {\r\n                        nodeName = sibling.nodeName;\r\n                        if ( nodeName === 'IMG' ||\r\n                                ( nodeName === '#text' &&\r\n                                    notWS.test( sibling.data ) ) ) {\r\n                            break;\r\n                        }\r\n                        if ( !isInline( sibling ) ) {\r\n                            sibling = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                    data = data.replace( /^[ \\t\\r\\n]+/g, sibling ? ' ' : '' );\r\n                }\r\n                if ( endsWithWS ) {\r\n                    walker.currentNode = child;\r\n                    while ( sibling = walker.nextNode() ) {\r\n                        if ( nodeName === 'IMG' ||\r\n                                ( nodeName === '#text' &&\r\n                                    notWS.test( sibling.data ) ) ) {\r\n                            break;\r\n                        }\r\n                        if ( !isInline( sibling ) ) {\r\n                            sibling = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                    data = data.replace( /[ \\t\\r\\n]+$/g, sibling ? ' ' : '' );\r\n                }\r\n                if ( data ) {\r\n                    child.data = data;\r\n                    continue;\r\n                }\r\n            }\r\n            node.removeChild( child );\r\n            i -= 1;\r\n            l -= 1;\r\n        }\r\n    }\r\n    return node;\r\n};\r\n\r\n// ---\r\n\r\nvar removeEmptyInlines = function removeEmptyInlines ( node ) {\r\n    var children = node.childNodes,\r\n        l = children.length,\r\n        child;\r\n    while ( l-- ) {\r\n        child = children[l];\r\n        if ( child.nodeType === ELEMENT_NODE && !isLeaf( child ) ) {\r\n            removeEmptyInlines( child );\r\n            if ( isInline( child ) && !child.firstChild ) {\r\n                node.removeChild( child );\r\n            }\r\n        } else if ( child.nodeType === TEXT_NODE && !child.data ) {\r\n            node.removeChild( child );\r\n        }\r\n    }\r\n};\r\n\r\n// ---\r\n\r\nvar notWSTextNode = function ( node ) {\r\n    return node.nodeType === ELEMENT_NODE ?\r\n        node.nodeName === 'BR' :\r\n        notWS.test( node.data );\r\n};\r\nvar isLineBreak = function ( br, isLBIfEmptyBlock ) {\r\n    var block = br.parentNode;\r\n    var walker;\r\n    while ( isInline( block ) ) {\r\n        block = block.parentNode;\r\n    }\r\n    walker = new TreeWalker(\r\n        block, SHOW_ELEMENT|SHOW_TEXT, notWSTextNode );\r\n    walker.currentNode = br;\r\n    return !!walker.nextNode() ||\r\n        ( isLBIfEmptyBlock && !walker.previousNode() );\r\n};\r\n\r\n// <br> elements are treated specially, and differently depending on the\r\n// browser, when in rich text editor mode. When adding HTML from external\r\n// sources, we must remove them, replacing the ones that actually affect\r\n// line breaks by wrapping the inline text in a <div>. Browsers that want <br>\r\n// elements at the end of each block will then have them added back in a later\r\n// fixCursor method call.\r\nvar cleanupBRs = function ( node, root, keepForBlankLine ) {\r\n    var brs = node.querySelectorAll( 'BR' );\r\n    var brBreaksLine = [];\r\n    var l = brs.length;\r\n    var i, br, parent;\r\n\r\n    // Must calculate whether the <br> breaks a line first, because if we\r\n    // have two <br>s next to each other, after the first one is converted\r\n    // to a block split, the second will be at the end of a block and\r\n    // therefore seem to not be a line break. But in its original context it\r\n    // was, so we should also convert it to a block split.\r\n    for ( i = 0; i < l; i += 1 ) {\r\n        brBreaksLine[i] = isLineBreak( brs[i], keepForBlankLine );\r\n    }\r\n    while ( l-- ) {\r\n        br = brs[l];\r\n        // Cleanup may have removed it\r\n        parent = br.parentNode;\r\n        if ( !parent ) { continue; }\r\n        // If it doesn't break a line, just remove it; it's not doing\r\n        // anything useful. We'll add it back later if required by the\r\n        // browser. If it breaks a line, wrap the content in div tags\r\n        // and replace the brs.\r\n        if ( !brBreaksLine[l] ) {\r\n            detach( br );\r\n        } else if ( !isInline( parent ) ) {\r\n            fixContainer( parent, root );\r\n        }\r\n    }\r\n};\r\n\r\n// The (non-standard but supported enough) innerText property is based on the\r\n// render tree in Firefox and possibly other browsers, so we must insert the\r\n// DOM node into the document to ensure the text part is correct.\r\nvar setClipboardData = function ( clipboardData, node, root ) {\r\n    var body = node.ownerDocument.body;\r\n    var html, text;\r\n\r\n    // Firefox will add an extra new line for BRs at the end of block when\r\n    // calculating innerText, even though they don't actually affect display.\r\n    // So we need to remove them first.\r\n    cleanupBRs( node, root, true );\r\n\r\n    node.setAttribute( 'style',\r\n        'position:fixed;overflow:hidden;bottom:100%;right:100%;' );\r\n    body.appendChild( node );\r\n    html = node.innerHTML;\r\n    text = node.innerText || node.textContent;\r\n\r\n    // Firefox (and others?) returns unix line endings (\\n) even on Windows.\r\n    // If on Windows, normalise to \\r\\n, since Notepad and some other crappy\r\n    // apps do not understand just \\n.\r\n    if ( isWin ) {\r\n        text = text.replace( /\\r?\\n/g, '\\r\\n' );\r\n    }\r\n\r\n    clipboardData.setData( 'text/html', html );\r\n    clipboardData.setData( 'text/plain', text );\r\n\r\n    body.removeChild( node );\r\n};\r\n\r\nvar onCut = function ( event ) {\r\n    var clipboardData = event.clipboardData;\r\n    var range = this.getSelection();\r\n    var root = this._root;\r\n    var self = this;\r\n    var startBlock, endBlock, copyRoot, contents, parent, newContents, node;\r\n\r\n    // Nothing to do\r\n    if ( range.collapsed ) {\r\n        event.preventDefault();\r\n        return;\r\n    }\r\n\r\n    // Save undo checkpoint\r\n    this.saveUndoState( range );\r\n\r\n    // Edge only seems to support setting plain text as of 2016-03-11.\r\n    // Mobile Safari flat out doesn't work:\r\n    // https://bugs.webkit.org/show_bug.cgi?id=143776\r\n    if ( !isEdge && !isIOS && clipboardData ) {\r\n        // Clipboard content should include all parents within block, or all\r\n        // parents up to root if selection across blocks\r\n        startBlock = getStartBlockOfRange( range, root );\r\n        endBlock = getEndBlockOfRange( range, root );\r\n        copyRoot = ( ( startBlock === endBlock ) && startBlock ) || root;\r\n        // Extract the contents\r\n        contents = deleteContentsOfRange( range, root );\r\n        // Add any other parents not in extracted content, up to copy root\r\n        parent = range.commonAncestorContainer;\r\n        if ( parent.nodeType === TEXT_NODE ) {\r\n            parent = parent.parentNode;\r\n        }\r\n        while ( parent && parent !== copyRoot ) {\r\n            newContents = parent.cloneNode( false );\r\n            newContents.appendChild( contents );\r\n            contents = newContents;\r\n            parent = parent.parentNode;\r\n        }\r\n        // Set clipboard data\r\n        node = this.createElement( 'div' );\r\n        node.appendChild( contents );\r\n        setClipboardData( clipboardData, node, root );\r\n        event.preventDefault();\r\n    } else {\r\n        setTimeout( function () {\r\n            try {\r\n                // If all content removed, ensure div at start of root.\r\n                self._ensureBottomLine();\r\n            } catch ( error ) {\r\n                self.didError( error );\r\n            }\r\n        }, 0 );\r\n    }\r\n\r\n    this.setSelection( range );\r\n};\r\n\r\nvar onCopy = function ( event ) {\r\n    var clipboardData = event.clipboardData;\r\n    var range = this.getSelection();\r\n    var root = this._root;\r\n    var startBlock, endBlock, copyRoot, contents, parent, newContents, node;\r\n\r\n    // Edge only seems to support setting plain text as of 2016-03-11.\r\n    // Mobile Safari flat out doesn't work:\r\n    // https://bugs.webkit.org/show_bug.cgi?id=143776\r\n    if ( !isEdge && !isIOS && clipboardData ) {\r\n        // Clipboard content should include all parents within block, or all\r\n        // parents up to root if selection across blocks\r\n        startBlock = getStartBlockOfRange( range, root );\r\n        endBlock = getEndBlockOfRange( range, root );\r\n        copyRoot = ( ( startBlock === endBlock ) && startBlock ) || root;\r\n        // Clone range to mutate, then move up as high as possible without\r\n        // passing the copy root node.\r\n        range = range.cloneRange();\r\n        moveRangeBoundariesDownTree( range );\r\n        moveRangeBoundariesUpTree( range, copyRoot, copyRoot, root );\r\n        // Extract the contents\r\n        contents = range.cloneContents();\r\n        // Add any other parents not in extracted content, up to copy root\r\n        parent = range.commonAncestorContainer;\r\n        if ( parent.nodeType === TEXT_NODE ) {\r\n            parent = parent.parentNode;\r\n        }\r\n        while ( parent && parent !== copyRoot ) {\r\n            newContents = parent.cloneNode( false );\r\n            newContents.appendChild( contents );\r\n            contents = newContents;\r\n            parent = parent.parentNode;\r\n        }\r\n        // Set clipboard data\r\n        node = this.createElement( 'div' );\r\n        node.appendChild( contents );\r\n        setClipboardData( clipboardData, node, root );\r\n        event.preventDefault();\r\n    }\r\n};\r\n\r\n// Need to monitor for shift key like this, as event.shiftKey is not available\r\n// in paste event.\r\nfunction monitorShiftKey ( event ) {\r\n    this.isShiftDown = event.shiftKey;\r\n}\r\n\r\nvar onPaste = function ( event ) {\r\n    var clipboardData = event.clipboardData;\r\n    var items = clipboardData && clipboardData.items;\r\n    var choosePlain = this.isShiftDown;\r\n    var fireDrop = false;\r\n    var hasImage = false;\r\n    var plainItem = null;\r\n    var self = this;\r\n    var l, item, type, types, data;\r\n\r\n    // Current HTML5 Clipboard interface\r\n    // ---------------------------------\r\n    // https://html.spec.whatwg.org/multipage/interaction.html\r\n\r\n    // Edge only provides access to plain text as of 2016-03-11 and gives no\r\n    // indication there should be an HTML part. However, it does support access\r\n    // to image data, so check if this is present and use if so.\r\n    if ( isEdge && items ) {\r\n        l = items.length;\r\n        while ( l-- ) {\r\n            if ( !choosePlain && /^image\\/.*/.test( items[l].type ) ) {\r\n                hasImage = true;\r\n            }\r\n        }\r\n        if ( !hasImage ) {\r\n            items = null;\r\n        }\r\n    }\r\n    if ( items ) {\r\n        event.preventDefault();\r\n        l = items.length;\r\n        while ( l-- ) {\r\n            item = items[l];\r\n            type = item.type;\r\n            if ( !choosePlain && type === 'text/html' ) {\r\n                /*jshint loopfunc: true */\r\n                item.getAsString( function ( html ) {\r\n                    self.insertHTML( html, true );\r\n                });\r\n                /*jshint loopfunc: false */\r\n                return;\r\n            }\r\n            if ( type === 'text/plain' ) {\r\n                plainItem = item;\r\n            }\r\n            if ( !choosePlain && /^image\\/.*/.test( type ) ) {\r\n                hasImage = true;\r\n            }\r\n        }\r\n        // Treat image paste as a drop of an image file.\r\n        if ( hasImage ) {\r\n            this.fireEvent( 'dragover', {\r\n                dataTransfer: clipboardData,\r\n                /*jshint loopfunc: true */\r\n                preventDefault: function () {\r\n                    fireDrop = true;\r\n                }\r\n                /*jshint loopfunc: false */\r\n            });\r\n            if ( fireDrop ) {\r\n                this.fireEvent( 'drop', {\r\n                    dataTransfer: clipboardData\r\n                });\r\n            }\r\n        } else if ( plainItem ) {\r\n            plainItem.getAsString( function ( text ) {\r\n                self.insertPlainText( text, true );\r\n            });\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Old interface\r\n    // -------------\r\n\r\n    // Safari (and indeed many other OS X apps) copies stuff as text/rtf\r\n    // rather than text/html; even from a webpage in Safari. The only way\r\n    // to get an HTML version is to fallback to letting the browser insert\r\n    // the content. Same for getting image data. *Sigh*.\r\n    //\r\n    // Firefox is even worse: it doesn't even let you know that there might be\r\n    // an RTF version on the clipboard, but it will also convert to HTML if you\r\n    // let the browser insert the content. I've filed\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1254028\r\n    types = clipboardData && clipboardData.types;\r\n    if ( !isEdge && types && (\r\n            indexOf.call( types, 'text/html' ) > -1 || (\r\n                !isGecko &&\r\n                indexOf.call( types, 'text/plain' ) > -1 &&\r\n                indexOf.call( types, 'text/rtf' ) < 0 )\r\n            )) {\r\n        event.preventDefault();\r\n        // Abiword on Linux copies a plain text and html version, but the HTML\r\n        // version is the empty string! So always try to get HTML, but if none,\r\n        // insert plain text instead. On iOS, Facebook (and possibly other\r\n        // apps?) copy links as type text/uri-list, but also insert a **blank**\r\n        // text/plain item onto the clipboard. Why? Who knows.\r\n        if ( !choosePlain && ( data = clipboardData.getData( 'text/html' ) ) ) {\r\n            this.insertHTML( data, true );\r\n        } else if (\r\n                ( data = clipboardData.getData( 'text/plain' ) ) ||\r\n                ( data = clipboardData.getData( 'text/uri-list' ) ) ) {\r\n            this.insertPlainText( data, true );\r\n        }\r\n        return;\r\n    }\r\n\r\n    // No interface. Includes all versions of IE :(\r\n    // --------------------------------------------\r\n\r\n    this._awaitingPaste = true;\r\n\r\n    var body = this._doc.body,\r\n        range = this.getSelection(),\r\n        startContainer = range.startContainer,\r\n        startOffset = range.startOffset,\r\n        endContainer = range.endContainer,\r\n        endOffset = range.endOffset;\r\n\r\n    // We need to position the pasteArea in the visible portion of the screen\r\n    // to stop the browser auto-scrolling.\r\n    var pasteArea = this.createElement( 'DIV', {\r\n        contenteditable: 'true',\r\n        style: 'position:fixed; overflow:hidden; top:0; right:100%; width:1px; height:1px;'\r\n    });\r\n    body.appendChild( pasteArea );\r\n    range.selectNodeContents( pasteArea );\r\n    this.setSelection( range );\r\n\r\n    // A setTimeout of 0 means this is added to the back of the\r\n    // single javascript thread, so it will be executed after the\r\n    // paste event.\r\n    setTimeout( function () {\r\n        try {\r\n            // IE sometimes fires the beforepaste event twice; make sure it is\r\n            // not run again before our after paste function is called.\r\n            self._awaitingPaste = false;\r\n\r\n            // Get the pasted content and clean\r\n            var html = '',\r\n                next = pasteArea,\r\n                first, range;\r\n\r\n            // #88: Chrome can apparently split the paste area if certain\r\n            // content is inserted; gather them all up.\r\n            while ( pasteArea = next ) {\r\n                next = pasteArea.nextSibling;\r\n                detach( pasteArea );\r\n                // Safari and IE like putting extra divs around things.\r\n                first = pasteArea.firstChild;\r\n                if ( first && first === pasteArea.lastChild &&\r\n                        first.nodeName === 'DIV' ) {\r\n                    pasteArea = first;\r\n                }\r\n                html += pasteArea.innerHTML;\r\n            }\r\n\r\n            range = self._createRange(\r\n                startContainer, startOffset, endContainer, endOffset );\r\n            self.setSelection( range );\r\n\r\n            if ( html ) {\r\n                self.insertHTML( html, true );\r\n            }\r\n        } catch ( error ) {\r\n            self.didError( error );\r\n        }\r\n    }, 0 );\r\n};\r\n\r\n// On Windows you can drag an drop text. We can't handle this ourselves, because\r\n// as far as I can see, there's no way to get the drop insertion point. So just\r\n// save an undo state and hope for the best.\r\nvar onDrop = function ( event ) {\r\n    var types = event.dataTransfer.types;\r\n    var l = types.length;\r\n    var hasPlain = false;\r\n    var hasHTML = false;\r\n    while ( l-- ) {\r\n        switch ( types[l] ) {\r\n        case 'text/plain':\r\n            hasPlain = true;\r\n            break;\r\n        case 'text/html':\r\n            hasHTML = true;\r\n            break;\r\n        default:\r\n            return;\r\n        }\r\n    }\r\n    if ( hasHTML || hasPlain ) {\r\n        this.saveUndoState();\r\n    }\r\n};\r\n\r\nfunction mergeObjects ( base, extras, mayOverride ) {\r\n    var prop, value;\r\n    if ( !base ) {\r\n        base = {};\r\n    }\r\n    if ( extras ) {\r\n        for ( prop in extras ) {\r\n            if ( mayOverride || !( prop in base ) ) {\r\n                value = extras[ prop ];\r\n                base[ prop ] = ( value && value.constructor === Object ) ?\r\n                    mergeObjects( base[ prop ], value, mayOverride ) :\r\n                    value;\r\n            }\r\n        }\r\n    }\r\n    return base;\r\n}\r\n\r\nfunction Squire ( root, config ) {\r\n    if ( root.nodeType === DOCUMENT_NODE ) {\r\n        root = root.body;\r\n    }\r\n    var doc = root.ownerDocument;\r\n    var win = doc.defaultView;\r\n    var mutation;\r\n\r\n    this._win = win;\r\n    this._doc = doc;\r\n    this._root = root;\r\n\r\n    this._events = {};\r\n\r\n    this._isFocused = false;\r\n    this._lastSelection = null;\r\n\r\n    // IE loses selection state of iframe on blur, so make sure we\r\n    // cache it just before it loses focus.\r\n    if ( losesSelectionOnBlur ) {\r\n        this.addEventListener( 'beforedeactivate', this.getSelection );\r\n    }\r\n\r\n    this._hasZWS = false;\r\n\r\n    this._lastAnchorNode = null;\r\n    this._lastFocusNode = null;\r\n    this._path = '';\r\n    this._willUpdatePath = false;\r\n\r\n    if ( 'onselectionchange' in doc ) {\r\n        this.addEventListener( 'selectionchange', this._updatePathOnEvent );\r\n    } else {\r\n        this.addEventListener( 'keyup', this._updatePathOnEvent );\r\n        this.addEventListener( 'mouseup', this._updatePathOnEvent );\r\n    }\r\n\r\n    this._undoIndex = -1;\r\n    this._undoStack = [];\r\n    this._undoStackLength = 0;\r\n    this._isInUndoState = false;\r\n    this._ignoreChange = false;\r\n    this._ignoreAllChanges = false;\r\n\r\n    if ( canObserveMutations ) {\r\n        mutation = new MutationObserver( this._docWasChanged.bind( this ) );\r\n        mutation.observe( root, {\r\n            childList: true,\r\n            attributes: true,\r\n            characterData: true,\r\n            subtree: true\r\n        });\r\n        this._mutation = mutation;\r\n    } else {\r\n        this.addEventListener( 'keyup', this._keyUpDetectChange );\r\n    }\r\n\r\n    // On blur, restore focus except if the user taps or clicks to focus a\r\n    // specific point. Can't actually use click event because focus happens\r\n    // before click, so use mousedown/touchstart\r\n    this._restoreSelection = false;\r\n    this.addEventListener( 'blur', enableRestoreSelection );\r\n    this.addEventListener( 'mousedown', disableRestoreSelection );\r\n    this.addEventListener( 'touchstart', disableRestoreSelection );\r\n    this.addEventListener( 'focus', restoreSelection );\r\n\r\n    // IE sometimes fires the beforepaste event twice; make sure it is not run\r\n    // again before our after paste function is called.\r\n    this._awaitingPaste = false;\r\n    this.addEventListener( isIElt11 ? 'beforecut' : 'cut', onCut );\r\n    this.addEventListener( 'copy', onCopy );\r\n    this.addEventListener( 'keydown', monitorShiftKey );\r\n    this.addEventListener( 'keyup', monitorShiftKey );\r\n    this.addEventListener( isIElt11 ? 'beforepaste' : 'paste', onPaste );\r\n    this.addEventListener( 'drop', onDrop );\r\n\r\n    // Opera does not fire keydown repeatedly.\r\n    this.addEventListener( isPresto ? 'keypress' : 'keydown', onKey );\r\n\r\n    // Add key handlers\r\n    this._keyHandlers = Object.create( keyHandlers );\r\n\r\n    // Override default properties\r\n    this.setConfig( config );\r\n\r\n    // Fix IE<10's buggy implementation of Text#splitText.\r\n    // If the split is at the end of the node, it doesn't insert the newly split\r\n    // node into the document, and sets its value to undefined rather than ''.\r\n    // And even if the split is not at the end, the original node is removed\r\n    // from the document and replaced by another, rather than just having its\r\n    // data shortened.\r\n    // We used to feature test for this, but then found the feature test would\r\n    // sometimes pass, but later on the buggy behaviour would still appear.\r\n    // I think IE10 does not have the same bug, but it doesn't hurt to replace\r\n    // its native fn too and then we don't need yet another UA category.\r\n    if ( isIElt11 ) {\r\n        win.Text.prototype.splitText = function ( offset ) {\r\n            var afterSplit = this.ownerDocument.createTextNode(\r\n                    this.data.slice( offset ) ),\r\n                next = this.nextSibling,\r\n                parent = this.parentNode,\r\n                toDelete = this.length - offset;\r\n            if ( next ) {\r\n                parent.insertBefore( afterSplit, next );\r\n            } else {\r\n                parent.appendChild( afterSplit );\r\n            }\r\n            if ( toDelete ) {\r\n                this.deleteData( offset, toDelete );\r\n            }\r\n            return afterSplit;\r\n        };\r\n    }\r\n\r\n    root.setAttribute( 'contenteditable', 'true' );\r\n\r\n    // Remove Firefox's built-in controls\r\n    try {\r\n        doc.execCommand( 'enableObjectResizing', false, 'false' );\r\n        doc.execCommand( 'enableInlineTableEditing', false, 'false' );\r\n    } catch ( error ) {}\r\n\r\n    root.__squire__ = this;\r\n\r\n    // Need to register instance before calling setHTML, so that the fixCursor\r\n    // function can lookup any default block tag options set.\r\n    this.setHTML( '' );\r\n}\r\n\r\nvar proto = Squire.prototype;\r\n\r\nvar sanitizeToDOMFragment = function ( html, isPaste, self ) {\r\n    var doc = self._doc;\r\n    var frag = html ? DOMPurify.sanitize( html, {\r\n        ALLOW_UNKNOWN_PROTOCOLS: true,\r\n        WHOLE_DOCUMENT: false,\r\n        RETURN_DOM: true,\r\n        RETURN_DOM_FRAGMENT: true\r\n    }) : null;\r\n    return frag ? doc.importNode( frag, true ) : doc.createDocumentFragment();\r\n};\r\n\r\nproto.setConfig = function ( config ) {\r\n    config = mergeObjects({\r\n        blockTag: 'DIV',\r\n        blockAttributes: null,\r\n        tagAttributes: {\r\n            blockquote: null,\r\n            ul: null,\r\n            ol: null,\r\n            li: null,\r\n            a: null\r\n        },\r\n        leafNodeNames: leafNodeNames,\r\n        undo: {\r\n            documentSizeThreshold: -1, // -1 means no threshold\r\n            undoLimit: -1 // -1 means no limit\r\n        },\r\n        isInsertedHTMLSanitized: true,\r\n        isSetHTMLSanitized: true,\r\n        sanitizeToDOMFragment:\r\n            typeof DOMPurify !== 'undefined' && DOMPurify.isSupported ?\r\n            sanitizeToDOMFragment : null\r\n\r\n    }, config, true );\r\n\r\n    // Users may specify block tag in lower case\r\n    config.blockTag = config.blockTag.toUpperCase();\r\n\r\n    this._config = config;\r\n\r\n    return this;\r\n};\r\n\r\nproto.createElement = function ( tag, props, children ) {\r\n    return createElement( this._doc, tag, props, children );\r\n};\r\n\r\nproto.createDefaultBlock = function ( children ) {\r\n    var config = this._config;\r\n    return fixCursor(\r\n        this.createElement( config.blockTag, config.blockAttributes, children ),\r\n        this._root\r\n    );\r\n};\r\n\r\nproto.didError = function ( error ) {\r\n    console.log( error );\r\n};\r\n\r\nproto.getDocument = function () {\r\n    return this._doc;\r\n};\r\nproto.getRoot = function () {\r\n    return this._root;\r\n};\r\n\r\nproto.modifyDocument = function ( modificationCallback ) {\r\n    var mutation = this._mutation;\r\n    if ( mutation ) {\r\n        if ( mutation.takeRecords().length ) {\r\n            this._docWasChanged();\r\n        }\r\n        mutation.disconnect();\r\n    }\r\n\r\n    this._ignoreAllChanges = true;\r\n    modificationCallback();\r\n    this._ignoreAllChanges = false;\r\n\r\n    if ( mutation ) {\r\n        mutation.observe( this._root, {\r\n            childList: true,\r\n            attributes: true,\r\n            characterData: true,\r\n            subtree: true\r\n        });\r\n        this._ignoreChange = false;\r\n    }\r\n};\r\n\r\n// --- Events ---\r\n\r\n// Subscribing to these events won't automatically add a listener to the\r\n// document node, since these events are fired in a custom manner by the\r\n// editor code.\r\nvar customEvents = {\r\n    pathChange: 1, select: 1, input: 1, undoStateChange: 1\r\n};\r\n\r\nproto.fireEvent = function ( type, event ) {\r\n    var handlers = this._events[ type ];\r\n    var isFocused, l, obj;\r\n    // UI code, especially modal views, may be monitoring for focus events and\r\n    // immediately removing focus. In certain conditions, this can cause the\r\n    // focus event to fire after the blur event, which can cause an infinite\r\n    // loop. So we detect whether we're actually focused/blurred before firing.\r\n    if ( /^(?:focus|blur)/.test( type ) ) {\r\n        isFocused = this._root === this._doc.activeElement;\r\n        if ( type === 'focus' ) {\r\n            if ( !isFocused || this._isFocused ) {\r\n                return this;\r\n            }\r\n            this._isFocused = true;\r\n        } else {\r\n            if ( isFocused || !this._isFocused ) {\r\n                return this;\r\n            }\r\n            this._isFocused = false;\r\n        }\r\n    }\r\n    if ( handlers ) {\r\n        if ( !event ) {\r\n            event = {};\r\n        }\r\n        if ( event.type !== type ) {\r\n            event.type = type;\r\n        }\r\n        // Clone handlers array, so any handlers added/removed do not affect it.\r\n        handlers = handlers.slice();\r\n        l = handlers.length;\r\n        while ( l-- ) {\r\n            obj = handlers[l];\r\n            try {\r\n                if ( obj.handleEvent ) {\r\n                    obj.handleEvent( event );\r\n                } else {\r\n                    obj.call( this, event );\r\n                }\r\n            } catch ( error ) {\r\n                error.details = 'Squire: fireEvent error. Event type: ' + type;\r\n                this.didError( error );\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\nproto.destroy = function () {\r\n    var events = this._events;\r\n    var type;\r\n\r\n    for ( type in events ) {\r\n        this.removeEventListener( type );\r\n    }\r\n    if ( this._mutation ) {\r\n        this._mutation.disconnect();\r\n    }\r\n    delete this._root.__squire__;\r\n\r\n    // Destroy undo stack\r\n    this._undoIndex = -1;\r\n    this._undoStack = [];\r\n    this._undoStackLength = 0;\r\n};\r\n\r\nproto.handleEvent = function ( event ) {\r\n    this.fireEvent( event.type, event );\r\n};\r\n\r\nproto.addEventListener = function ( type, fn ) {\r\n    var handlers = this._events[ type ];\r\n    var target = this._root;\r\n    if ( !fn ) {\r\n        this.didError({\r\n            name: 'Squire: addEventListener with null or undefined fn',\r\n            message: 'Event type: ' + type\r\n        });\r\n        return this;\r\n    }\r\n    if ( !handlers ) {\r\n        handlers = this._events[ type ] = [];\r\n        if ( !customEvents[ type ] ) {\r\n            if ( type === 'selectionchange' ) {\r\n                target = this._doc;\r\n            }\r\n            target.addEventListener( type, this, true );\r\n        }\r\n    }\r\n    handlers.push( fn );\r\n    return this;\r\n};\r\n\r\nproto.removeEventListener = function ( type, fn ) {\r\n    var handlers = this._events[ type ];\r\n    var target = this._root;\r\n    var l;\r\n    if ( handlers ) {\r\n        if ( fn ) {\r\n            l = handlers.length;\r\n            while ( l-- ) {\r\n                if ( handlers[l] === fn ) {\r\n                    handlers.splice( l, 1 );\r\n                }\r\n            }\r\n        } else {\r\n            handlers.length = 0;\r\n        }\r\n        if ( !handlers.length ) {\r\n            delete this._events[ type ];\r\n            if ( !customEvents[ type ] ) {\r\n                if ( type === 'selectionchange' ) {\r\n                    target = this._doc;\r\n                }\r\n                target.removeEventListener( type, this, true );\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n// --- Selection and Path ---\r\n\r\nproto._createRange =\r\n        function ( range, startOffset, endContainer, endOffset ) {\r\n    if ( range instanceof this._win.Range ) {\r\n        return range.cloneRange();\r\n    }\r\n    var domRange = this._doc.createRange();\r\n    domRange.setStart( range, startOffset );\r\n    if ( endContainer ) {\r\n        domRange.setEnd( endContainer, endOffset );\r\n    } else {\r\n        domRange.setEnd( range, startOffset );\r\n    }\r\n    return domRange;\r\n};\r\n\r\nproto.getCursorPosition = function ( range ) {\r\n    if ( ( !range && !( range = this.getSelection() ) ) ||\r\n            !range.getBoundingClientRect ) {\r\n        return null;\r\n    }\r\n    // Get the bounding rect\r\n    var rect = range.getBoundingClientRect();\r\n    var node, parent;\r\n    if ( rect && !rect.top ) {\r\n        this._ignoreChange = true;\r\n        node = this._doc.createElement( 'SPAN' );\r\n        node.textContent = ZWS;\r\n        insertNodeInRange( range, node );\r\n        rect = node.getBoundingClientRect();\r\n        parent = node.parentNode;\r\n        parent.removeChild( node );\r\n        mergeInlines( parent, range );\r\n    }\r\n    return rect;\r\n};\r\n\r\nproto._moveCursorTo = function ( toStart ) {\r\n    var root = this._root,\r\n        range = this._createRange( root, toStart ? 0 : root.childNodes.length );\r\n    moveRangeBoundariesDownTree( range );\r\n    this.setSelection( range );\r\n    return this;\r\n};\r\nproto.moveCursorToStart = function () {\r\n    return this._moveCursorTo( true );\r\n};\r\nproto.moveCursorToEnd = function () {\r\n    return this._moveCursorTo( false );\r\n};\r\n\r\nvar getWindowSelection = function ( self ) {\r\n    return self._win.getSelection() || null;\r\n};\r\n\r\nproto.setSelection = function ( range ) {\r\n    if ( range ) {\r\n        this._lastSelection = range;\r\n        // If we're setting selection, that automatically, and synchronously, // triggers a focus event. So just store the selection and mark it as\r\n        // needing restore on focus.\r\n        if ( !this._isFocused ) {\r\n            enableRestoreSelection.call( this );\r\n        } else if ( isAndroid && !this._restoreSelection ) {\r\n            // Android closes the keyboard on removeAllRanges() and doesn't\r\n            // open it again when addRange() is called, sigh.\r\n            // Since Android doesn't trigger a focus event in setSelection(),\r\n            // use a blur/focus dance to work around this by letting the\r\n            // selection be restored on focus.\r\n            // Need to check for !this._restoreSelection to avoid infinite loop\r\n            enableRestoreSelection.call( this );\r\n            this.blur();\r\n            this.focus();\r\n        } else {\r\n            // iOS bug: if you don't focus the iframe before setting the\r\n            // selection, you can end up in a state where you type but the input\r\n            // doesn't get directed into the contenteditable area but is instead\r\n            // lost in a black hole. Very strange.\r\n            if ( isIOS ) {\r\n                this._win.focus();\r\n            }\r\n            var sel = getWindowSelection( this );\r\n            if ( sel ) {\r\n                sel.removeAllRanges();\r\n                sel.addRange( range );\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\nproto.getSelection = function () {\r\n    var sel = getWindowSelection( this );\r\n    var root = this._root;\r\n    var selection, startContainer, endContainer, node;\r\n    // If not focused, always rely on cached selection; another function may\r\n    // have set it but the DOM is not modified until focus again\r\n    if ( this._isFocused && sel && sel.rangeCount ) {\r\n        selection  = sel.getRangeAt( 0 ).cloneRange();\r\n        startContainer = selection.startContainer;\r\n        endContainer = selection.endContainer;\r\n        // FF can return the selection as being inside an <img>. WTF?\r\n        if ( startContainer && isLeaf( startContainer ) ) {\r\n            selection.setStartBefore( startContainer );\r\n        }\r\n        if ( endContainer && isLeaf( endContainer ) ) {\r\n            selection.setEndBefore( endContainer );\r\n        }\r\n    }\r\n    if ( selection &&\r\n            isOrContains( root, selection.commonAncestorContainer ) ) {\r\n        this._lastSelection = selection;\r\n    } else {\r\n        selection = this._lastSelection;\r\n        node = selection.commonAncestorContainer;\r\n        // Check the editor is in the live document; if not, the range has\r\n        // probably been rewritten by the browser and is bogus\r\n        if ( !isOrContains( node.ownerDocument, node ) ) {\r\n            selection = null;\r\n        }\r\n    }\r\n    if ( !selection ) {\r\n        selection = this._createRange( root.firstChild, 0 );\r\n    }\r\n    return selection;\r\n};\r\n\r\nfunction enableRestoreSelection () {\r\n    this._restoreSelection = true;\r\n}\r\nfunction disableRestoreSelection () {\r\n    this._restoreSelection = false;\r\n}\r\nfunction restoreSelection () {\r\n    if ( this._restoreSelection ) {\r\n        this.setSelection( this._lastSelection );\r\n    }\r\n}\r\n\r\nproto.getSelectedText = function () {\r\n    var range = this.getSelection();\r\n    if ( !range || range.collapsed ) {\r\n        return '';\r\n    }\r\n    var walker = new TreeWalker(\r\n        range.commonAncestorContainer,\r\n        SHOW_TEXT|SHOW_ELEMENT,\r\n        function ( node ) {\r\n            return isNodeContainedInRange( range, node, true );\r\n        }\r\n    );\r\n    var startContainer = range.startContainer;\r\n    var endContainer = range.endContainer;\r\n    var node = walker.currentNode = startContainer;\r\n    var textContent = '';\r\n    var addedTextInBlock = false;\r\n    var value;\r\n\r\n    if ( !walker.filter( node ) ) {\r\n        node = walker.nextNode();\r\n    }\r\n\r\n    while ( node ) {\r\n        if ( node.nodeType === TEXT_NODE ) {\r\n            value = node.data;\r\n            if ( value && ( /\\S/.test( value ) ) ) {\r\n                if ( node === endContainer ) {\r\n                    value = value.slice( 0, range.endOffset );\r\n                }\r\n                if ( node === startContainer ) {\r\n                    value = value.slice( range.startOffset );\r\n                }\r\n                textContent += value;\r\n                addedTextInBlock = true;\r\n            }\r\n        } else if ( node.nodeName === 'BR' ||\r\n                addedTextInBlock && !isInline( node ) ) {\r\n            textContent += '\\n';\r\n            addedTextInBlock = false;\r\n        }\r\n        node = walker.nextNode();\r\n    }\r\n\r\n    return textContent;\r\n};\r\n\r\nproto.getPath = function () {\r\n    return this._path;\r\n};\r\n\r\n// --- Workaround for browsers that can't focus empty text nodes ---\r\n\r\n// WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=15256\r\n\r\n// Walk down the tree starting at the root and remove any ZWS. If the node only\r\n// contained ZWS space then remove it too. We may want to keep one ZWS node at\r\n// the bottom of the tree so the block can be selected. Define that node as the\r\n// keepNode.\r\nvar removeZWS = function ( root, keepNode ) {\r\n    var walker = new TreeWalker( root, SHOW_TEXT, function () {\r\n            return true;\r\n        }, false ),\r\n        parent, node, index;\r\n    while ( node = walker.nextNode() ) {\r\n        while ( ( index = node.data.indexOf( ZWS ) ) > -1  &&\r\n                ( !keepNode || node.parentNode !== keepNode ) ) {\r\n            if ( node.length === 1 ) {\r\n                do {\r\n                    parent = node.parentNode;\r\n                    parent.removeChild( node );\r\n                    node = parent;\r\n                    walker.currentNode = parent;\r\n                } while ( isInline( node ) && !getLength( node ) );\r\n                break;\r\n            } else {\r\n                node.deleteData( index, 1 );\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nproto._didAddZWS = function () {\r\n    this._hasZWS = true;\r\n};\r\nproto._removeZWS = function () {\r\n    if ( !this._hasZWS ) {\r\n        return;\r\n    }\r\n    removeZWS( this._root );\r\n    this._hasZWS = false;\r\n};\r\n\r\n// --- Path change events ---\r\n\r\nproto._updatePath = function ( range, force ) {\r\n    if ( !range ) {\r\n        return;\r\n    }\r\n    var anchor = range.startContainer,\r\n        focus = range.endContainer,\r\n        newPath;\r\n    if ( force || anchor !== this._lastAnchorNode ||\r\n            focus !== this._lastFocusNode ) {\r\n        this._lastAnchorNode = anchor;\r\n        this._lastFocusNode = focus;\r\n        newPath = ( anchor && focus ) ? ( anchor === focus ) ?\r\n            getPath( focus, this._root ) : '(selection)' : '';\r\n        if ( this._path !== newPath ) {\r\n            this._path = newPath;\r\n            this.fireEvent( 'pathChange', { path: newPath } );\r\n        }\r\n    }\r\n    this.fireEvent( range.collapsed ? 'cursor' : 'select', {\r\n        range: range\r\n    });\r\n};\r\n\r\n// selectionchange is fired synchronously in IE when removing current selection\r\n// and when setting new selection; keyup/mouseup may have processing we want\r\n// to do first. Either way, send to next event loop.\r\nproto._updatePathOnEvent = function ( event ) {\r\n    var self = this;\r\n    if ( self._isFocused && !self._willUpdatePath ) {\r\n        self._willUpdatePath = true;\r\n        setTimeout( function () {\r\n            self._willUpdatePath = false;\r\n            self._updatePath( self.getSelection() );\r\n        }, 0 );\r\n    }\r\n};\r\n\r\n// --- Focus ---\r\n\r\nproto.focus = function () {\r\n    this._root.focus();\r\n\r\n    if ( isIE ) {\r\n        this.fireEvent( 'focus' );\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nproto.blur = function () {\r\n    this._root.blur();\r\n\r\n    if ( isIE ) {\r\n        this.fireEvent( 'blur' );\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n// --- Bookmarking ---\r\n\r\nvar startSelectionId = 'squire-selection-start';\r\nvar endSelectionId = 'squire-selection-end';\r\n\r\nproto._saveRangeToBookmark = function ( range ) {\r\n    var startNode = this.createElement( 'INPUT', {\r\n            id: startSelectionId,\r\n            type: 'hidden'\r\n        }),\r\n        endNode = this.createElement( 'INPUT', {\r\n            id: endSelectionId,\r\n            type: 'hidden'\r\n        }),\r\n        temp;\r\n\r\n    insertNodeInRange( range, startNode );\r\n    range.collapse( false );\r\n    insertNodeInRange( range, endNode );\r\n\r\n    // In a collapsed range, the start is sometimes inserted after the end!\r\n    if ( startNode.compareDocumentPosition( endNode ) &\r\n            DOCUMENT_POSITION_PRECEDING ) {\r\n        startNode.id = endSelectionId;\r\n        endNode.id = startSelectionId;\r\n        temp = startNode;\r\n        startNode = endNode;\r\n        endNode = temp;\r\n    }\r\n\r\n    range.setStartAfter( startNode );\r\n    range.setEndBefore( endNode );\r\n};\r\n\r\nproto._getRangeAndRemoveBookmark = function ( range ) {\r\n    var root = this._root,\r\n        start = root.querySelector( '#' + startSelectionId ),\r\n        end = root.querySelector( '#' + endSelectionId );\r\n\r\n    if ( start && end ) {\r\n        var startContainer = start.parentNode,\r\n            endContainer = end.parentNode,\r\n            startOffset = indexOf.call( startContainer.childNodes, start ),\r\n            endOffset = indexOf.call( endContainer.childNodes, end );\r\n\r\n        if ( startContainer === endContainer ) {\r\n            endOffset -= 1;\r\n        }\r\n\r\n        detach( start );\r\n        detach( end );\r\n\r\n        if ( !range ) {\r\n            range = this._doc.createRange();\r\n        }\r\n        range.setStart( startContainer, startOffset );\r\n        range.setEnd( endContainer, endOffset );\r\n\r\n        // Merge any text nodes we split\r\n        mergeInlines( startContainer, range );\r\n        if ( startContainer !== endContainer ) {\r\n            mergeInlines( endContainer, range );\r\n        }\r\n\r\n        // If we didn't split a text node, we should move into any adjacent\r\n        // text node to current selection point\r\n        if ( range.collapsed ) {\r\n            startContainer = range.startContainer;\r\n            if ( startContainer.nodeType === TEXT_NODE ) {\r\n                endContainer = startContainer.childNodes[ range.startOffset ];\r\n                if ( !endContainer || endContainer.nodeType !== TEXT_NODE ) {\r\n                    endContainer =\r\n                        startContainer.childNodes[ range.startOffset - 1 ];\r\n                }\r\n                if ( endContainer && endContainer.nodeType === TEXT_NODE ) {\r\n                    range.setStart( endContainer, 0 );\r\n                    range.collapse( true );\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return range || null;\r\n};\r\n\r\n// --- Undo ---\r\n\r\nproto._keyUpDetectChange = function ( event ) {\r\n    var code = event.keyCode;\r\n    // Presume document was changed if:\r\n    // 1. A modifier key (other than shift) wasn't held down\r\n    // 2. The key pressed is not in range 16<=x<=20 (control keys)\r\n    // 3. The key pressed is not in range 33<=x<=45 (navigation keys)\r\n    if ( !event.ctrlKey && !event.metaKey && !event.altKey &&\r\n            ( code < 16 || code > 20 ) &&\r\n            ( code < 33 || code > 45 ) ) {\r\n        this._docWasChanged();\r\n    }\r\n};\r\n\r\nproto._docWasChanged = function () {\r\n    if ( canWeakMap ) {\r\n        nodeCategoryCache = new WeakMap();\r\n    }\r\n    if ( this._ignoreAllChanges ) {\r\n        return;\r\n    }\r\n\r\n    if ( canObserveMutations && this._ignoreChange ) {\r\n        this._ignoreChange = false;\r\n        return;\r\n    }\r\n    if ( this._isInUndoState ) {\r\n        this._isInUndoState = false;\r\n        this.fireEvent( 'undoStateChange', {\r\n            canUndo: true,\r\n            canRedo: false\r\n        });\r\n    }\r\n    this.fireEvent( 'input' );\r\n};\r\n\r\n// Leaves bookmark\r\nproto._recordUndoState = function ( range, replace ) {\r\n    // Don't record if we're already in an undo state\r\n    if ( !this._isInUndoState|| replace ) {\r\n        // Advance pointer to new position\r\n        var undoIndex = this._undoIndex;\r\n        var undoStack = this._undoStack;\r\n        var undoConfig = this._config.undo;\r\n        var undoThreshold = undoConfig.documentSizeThreshold;\r\n        var undoLimit = undoConfig.undoLimit;\r\n        var html;\r\n\r\n        if ( !replace ) {\r\n            undoIndex += 1;\r\n        }\r\n\r\n        // Truncate stack if longer (i.e. if has been previously undone)\r\n        if ( undoIndex < this._undoStackLength ) {\r\n            undoStack.length = this._undoStackLength = undoIndex;\r\n        }\r\n\r\n        // Get data\r\n        if ( range ) {\r\n            this._saveRangeToBookmark( range );\r\n        }\r\n        html = this._getHTML();\r\n\r\n        // If this document is above the configured size threshold,\r\n        // limit the number of saved undo states.\r\n        // Threshold is in bytes, JS uses 2 bytes per character\r\n        if ( undoThreshold > -1 && html.length * 2 > undoThreshold ) {\r\n            if ( undoLimit > -1 && undoIndex > undoLimit ) {\r\n                undoStack.splice( 0, undoIndex - undoLimit );\r\n                undoIndex = undoLimit;\r\n                this._undoStackLength = undoLimit;\r\n            }\r\n        }\r\n\r\n        // Save data\r\n        undoStack[ undoIndex ] = html;\r\n        this._undoIndex = undoIndex;\r\n        this._undoStackLength += 1;\r\n        this._isInUndoState = true;\r\n    }\r\n};\r\n\r\nproto.saveUndoState = function ( range ) {\r\n    if ( range === undefined ) {\r\n        range = this.getSelection();\r\n    }\r\n    this._recordUndoState( range, this._isInUndoState );\r\n    this._getRangeAndRemoveBookmark( range );\r\n\r\n    return this;\r\n};\r\n\r\nproto.undo = function () {\r\n    // Sanity check: must not be at beginning of the history stack\r\n    if ( this._undoIndex !== 0 || !this._isInUndoState ) {\r\n        // Make sure any changes since last checkpoint are saved.\r\n        this._recordUndoState( this.getSelection(), false );\r\n\r\n        this._undoIndex -= 1;\r\n        this._setHTML( this._undoStack[ this._undoIndex ] );\r\n        var range = this._getRangeAndRemoveBookmark();\r\n        if ( range ) {\r\n            this.setSelection( range );\r\n        }\r\n        this._isInUndoState = true;\r\n        this.fireEvent( 'undoStateChange', {\r\n            canUndo: this._undoIndex !== 0,\r\n            canRedo: true\r\n        });\r\n        this.fireEvent( 'input' );\r\n    }\r\n    return this;\r\n};\r\n\r\nproto.redo = function () {\r\n    // Sanity check: must not be at end of stack and must be in an undo\r\n    // state.\r\n    var undoIndex = this._undoIndex,\r\n        undoStackLength = this._undoStackLength;\r\n    if ( undoIndex + 1 < undoStackLength && this._isInUndoState ) {\r\n        this._undoIndex += 1;\r\n        this._setHTML( this._undoStack[ this._undoIndex ] );\r\n        var range = this._getRangeAndRemoveBookmark();\r\n        if ( range ) {\r\n            this.setSelection( range );\r\n        }\r\n        this.fireEvent( 'undoStateChange', {\r\n            canUndo: true,\r\n            canRedo: undoIndex + 2 < undoStackLength\r\n        });\r\n        this.fireEvent( 'input' );\r\n    }\r\n    return this;\r\n};\r\n\r\n// --- Inline formatting ---\r\n\r\n// Looks for matching tag and attributes, so won't work\r\n// if <strong> instead of <b> etc.\r\nproto.hasFormat = function ( tag, attributes, range ) {\r\n    // 1. Normalise the arguments and get selection\r\n    tag = tag.toUpperCase();\r\n    if ( !attributes ) { attributes = {}; }\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return false;\r\n    }\r\n\r\n    // Sanitize range to prevent weird IE artifacts\r\n    if ( !range.collapsed &&\r\n            range.startContainer.nodeType === TEXT_NODE &&\r\n            range.startOffset === range.startContainer.length &&\r\n            range.startContainer.nextSibling ) {\r\n        range.setStartBefore( range.startContainer.nextSibling );\r\n    }\r\n    if ( !range.collapsed &&\r\n            range.endContainer.nodeType === TEXT_NODE &&\r\n            range.endOffset === 0 &&\r\n            range.endContainer.previousSibling ) {\r\n        range.setEndAfter( range.endContainer.previousSibling );\r\n    }\r\n\r\n    // If the common ancestor is inside the tag we require, we definitely\r\n    // have the format.\r\n    var root = this._root;\r\n    var common = range.commonAncestorContainer;\r\n    var walker, node;\r\n    if ( getNearest( common, root, tag, attributes ) ) {\r\n        return true;\r\n    }\r\n\r\n    // If common ancestor is a text node and doesn't have the format, we\r\n    // definitely don't have it.\r\n    if ( common.nodeType === TEXT_NODE ) {\r\n        return false;\r\n    }\r\n\r\n    // Otherwise, check each text node at least partially contained within\r\n    // the selection and make sure all of them have the format we want.\r\n    walker = new TreeWalker( common, SHOW_TEXT, function ( node ) {\r\n        return isNodeContainedInRange( range, node, true );\r\n    }, false );\r\n\r\n    var seenNode = false;\r\n    while ( node = walker.nextNode() ) {\r\n        if ( !getNearest( node, root, tag, attributes ) ) {\r\n            return false;\r\n        }\r\n        seenNode = true;\r\n    }\r\n\r\n    return seenNode;\r\n};\r\n\r\n// Extracts the font-family and font-size (if any) of the element\r\n// holding the cursor. If there's a selection, returns an empty object.\r\nproto.getFontInfo = function ( range ) {\r\n    var fontInfo = {\r\n        color: undefined,\r\n        backgroundColor: undefined,\r\n        family: undefined,\r\n        size: undefined\r\n    };\r\n    var seenAttributes = 0;\r\n    var element, style, attr;\r\n\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return fontInfo;\r\n    }\r\n\r\n    element = range.commonAncestorContainer;\r\n    if ( range.collapsed || element.nodeType === TEXT_NODE ) {\r\n        if ( element.nodeType === TEXT_NODE ) {\r\n            element = element.parentNode;\r\n        }\r\n        while ( seenAttributes < 4 && element ) {\r\n            if ( style = element.style ) {\r\n                if ( !fontInfo.color && ( attr = style.color ) ) {\r\n                    fontInfo.color = attr;\r\n                    seenAttributes += 1;\r\n                }\r\n                if ( !fontInfo.backgroundColor &&\r\n                        ( attr = style.backgroundColor ) ) {\r\n                    fontInfo.backgroundColor = attr;\r\n                    seenAttributes += 1;\r\n                }\r\n                if ( !fontInfo.family && ( attr = style.fontFamily ) ) {\r\n                    fontInfo.family = attr;\r\n                    seenAttributes += 1;\r\n                }\r\n                if ( !fontInfo.size && ( attr = style.fontSize ) ) {\r\n                    fontInfo.size = attr;\r\n                    seenAttributes += 1;\r\n                }\r\n            }\r\n            element = element.parentNode;\r\n        }\r\n    }\r\n    return fontInfo;\r\n};\r\n\r\nproto._addFormat = function ( tag, attributes, range ) {\r\n    // If the range is collapsed we simply insert the node by wrapping\r\n    // it round the range and focus it.\r\n    var root = this._root;\r\n    var el, walker, startContainer, endContainer, startOffset, endOffset,\r\n        node, needsFormat, block;\r\n\r\n    if ( range.collapsed ) {\r\n        el = fixCursor( this.createElement( tag, attributes ), root );\r\n        insertNodeInRange( range, el );\r\n        range.setStart( el.firstChild, el.firstChild.length );\r\n        range.collapse( true );\r\n\r\n        // Clean up any previous formats that may have been set on this block\r\n        // that are unused.\r\n        block = el;\r\n        while ( isInline( block ) ) {\r\n            block = block.parentNode;\r\n        }\r\n        removeZWS( block, el );\r\n    }\r\n    // Otherwise we find all the textnodes in the range (splitting\r\n    // partially selected nodes) and if they're not already formatted\r\n    // correctly we wrap them in the appropriate tag.\r\n    else {\r\n        // Create an iterator to walk over all the text nodes under this\r\n        // ancestor which are in the range and not already formatted\r\n        // correctly.\r\n        //\r\n        // In Blink/WebKit, empty blocks may have no text nodes, just a <br>.\r\n        // Therefore we wrap this in the tag as well, as this will then cause it\r\n        // to apply when the user types something in the block, which is\r\n        // presumably what was intended.\r\n        //\r\n        // IMG tags are included because we may want to create a link around\r\n        // them, and adding other styles is harmless.\r\n        walker = new TreeWalker(\r\n            range.commonAncestorContainer,\r\n            SHOW_TEXT|SHOW_ELEMENT,\r\n            function ( node ) {\r\n                return ( node.nodeType === TEXT_NODE ||\r\n                        node.nodeName === 'BR' ||\r\n                        node.nodeName === 'IMG'\r\n                    ) && isNodeContainedInRange( range, node, true );\r\n            },\r\n            false\r\n        );\r\n\r\n        // Start at the beginning node of the range and iterate through\r\n        // all the nodes in the range that need formatting.\r\n        startContainer = range.startContainer;\r\n        startOffset = range.startOffset;\r\n        endContainer = range.endContainer;\r\n        endOffset = range.endOffset;\r\n\r\n        // Make sure we start with a valid node.\r\n        walker.currentNode = startContainer;\r\n        if ( !walker.filter( startContainer ) ) {\r\n            startContainer = walker.nextNode();\r\n            startOffset = 0;\r\n        }\r\n\r\n        // If there are no interesting nodes in the selection, abort\r\n        if ( !startContainer ) {\r\n            return range;\r\n        }\r\n\r\n        do {\r\n            node = walker.currentNode;\r\n            needsFormat = !getNearest( node, root, tag, attributes );\r\n            if ( needsFormat ) {\r\n                // <br> can never be a container node, so must have a text node\r\n                // if node == (end|start)Container\r\n                if ( node === endContainer && node.length > endOffset ) {\r\n                    node.splitText( endOffset );\r\n                }\r\n                if ( node === startContainer && startOffset ) {\r\n                    node = node.splitText( startOffset );\r\n                    if ( endContainer === startContainer ) {\r\n                        endContainer = node;\r\n                        endOffset -= startOffset;\r\n                    }\r\n                    startContainer = node;\r\n                    startOffset = 0;\r\n                }\r\n                el = this.createElement( tag, attributes );\r\n                replaceWith( node, el );\r\n                el.appendChild( node );\r\n            }\r\n        } while ( walker.nextNode() );\r\n\r\n        // If we don't finish inside a text node, offset may have changed.\r\n        if ( endContainer.nodeType !== TEXT_NODE ) {\r\n            if ( node.nodeType === TEXT_NODE ) {\r\n                endContainer = node;\r\n                endOffset = node.length;\r\n            } else {\r\n                // If <br>, we must have just wrapped it, so it must have only\r\n                // one child\r\n                endContainer = node.parentNode;\r\n                endOffset = 1;\r\n            }\r\n        }\r\n\r\n        // Now set the selection to as it was before\r\n        range = this._createRange(\r\n            startContainer, startOffset, endContainer, endOffset );\r\n    }\r\n    return range;\r\n};\r\n\r\nproto._removeFormat = function ( tag, attributes, range, partial ) {\r\n    // Add bookmark\r\n    this._saveRangeToBookmark( range );\r\n\r\n    // We need a node in the selection to break the surrounding\r\n    // formatted text.\r\n    var doc = this._doc,\r\n        fixer;\r\n    if ( range.collapsed ) {\r\n        if ( cantFocusEmptyTextNodes ) {\r\n            fixer = doc.createTextNode( ZWS );\r\n            this._didAddZWS();\r\n        } else {\r\n            fixer = doc.createTextNode( '' );\r\n        }\r\n        insertNodeInRange( range, fixer );\r\n    }\r\n\r\n    // Find block-level ancestor of selection\r\n    var root = range.commonAncestorContainer;\r\n    while ( isInline( root ) ) {\r\n        root = root.parentNode;\r\n    }\r\n\r\n    // Find text nodes inside formatTags that are not in selection and\r\n    // add an extra tag with the same formatting.\r\n    var startContainer = range.startContainer,\r\n        startOffset = range.startOffset,\r\n        endContainer = range.endContainer,\r\n        endOffset = range.endOffset,\r\n        toWrap = [],\r\n        examineNode = function ( node, exemplar ) {\r\n            // If the node is completely contained by the range then\r\n            // we're going to remove all formatting so ignore it.\r\n            if ( isNodeContainedInRange( range, node, false ) ) {\r\n                return;\r\n            }\r\n\r\n            var isText = ( node.nodeType === TEXT_NODE ),\r\n                child, next;\r\n\r\n            // If not at least partially contained, wrap entire contents\r\n            // in a clone of the tag we're removing and we're done.\r\n            if ( !isNodeContainedInRange( range, node, true ) ) {\r\n                // Ignore bookmarks and empty text nodes\r\n                if ( node.nodeName !== 'INPUT' &&\r\n                        ( !isText || node.data ) ) {\r\n                    toWrap.push([ exemplar, node ]);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // Split any partially selected text nodes.\r\n            if ( isText ) {\r\n                if ( node === endContainer && endOffset !== node.length ) {\r\n                    toWrap.push([ exemplar, node.splitText( endOffset ) ]);\r\n                }\r\n                if ( node === startContainer && startOffset ) {\r\n                    node.splitText( startOffset );\r\n                    toWrap.push([ exemplar, node ]);\r\n                }\r\n            }\r\n            // If not a text node, recurse onto all children.\r\n            // Beware, the tree may be rewritten with each call\r\n            // to examineNode, hence find the next sibling first.\r\n            else {\r\n                for ( child = node.firstChild; child; child = next ) {\r\n                    next = child.nextSibling;\r\n                    examineNode( child, exemplar );\r\n                }\r\n            }\r\n        },\r\n        formatTags = Array.prototype.filter.call(\r\n            root.getElementsByTagName( tag ), function ( el ) {\r\n                return isNodeContainedInRange( range, el, true ) &&\r\n                    hasTagAttributes( el, tag, attributes );\r\n            }\r\n        );\r\n\r\n    if ( !partial ) {\r\n        formatTags.forEach( function ( node ) {\r\n            examineNode( node, node );\r\n        });\r\n    }\r\n\r\n    // Now wrap unselected nodes in the tag\r\n    toWrap.forEach( function ( item ) {\r\n        // [ exemplar, node ] tuple\r\n        var el = item[0].cloneNode( false ),\r\n            node = item[1];\r\n        replaceWith( node, el );\r\n        el.appendChild( node );\r\n    });\r\n    // and remove old formatting tags.\r\n    formatTags.forEach( function ( el ) {\r\n        replaceWith( el, empty( el ) );\r\n    });\r\n\r\n    // Merge adjacent inlines:\r\n    this._getRangeAndRemoveBookmark( range );\r\n    if ( fixer ) {\r\n        range.collapse( false );\r\n    }\r\n    mergeInlines( root, range );\r\n\r\n    return range;\r\n};\r\n\r\nproto.changeFormat = function ( add, remove, range, partial ) {\r\n    // Normalise the arguments and get selection\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return this;\r\n    }\r\n\r\n    // Save undo checkpoint\r\n    this.saveUndoState( range );\r\n\r\n    if ( remove ) {\r\n        range = this._removeFormat( remove.tag.toUpperCase(),\r\n            remove.attributes || {}, range, partial );\r\n    }\r\n    if ( add ) {\r\n        range = this._addFormat( add.tag.toUpperCase(),\r\n            add.attributes || {}, range );\r\n    }\r\n\r\n    this.setSelection( range );\r\n    this._updatePath( range, true );\r\n\r\n    // We're not still in an undo state\r\n    if ( !canObserveMutations ) {\r\n        this._docWasChanged();\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n// --- Block formatting ---\r\n\r\nvar tagAfterSplit = {\r\n    DT:  'DD',\r\n    DD:  'DT',\r\n    LI:  'LI',\r\n    PRE: 'PRE'\r\n};\r\n\r\nvar splitBlock = function ( self, block, node, offset ) {\r\n    var splitTag = tagAfterSplit[ block.nodeName ],\r\n        splitProperties = null,\r\n        nodeAfterSplit = split( node, offset, block.parentNode, self._root ),\r\n        config = self._config;\r\n\r\n    if ( !splitTag ) {\r\n        splitTag = config.blockTag;\r\n        splitProperties = config.blockAttributes;\r\n    }\r\n\r\n    // Make sure the new node is the correct type.\r\n    if ( !hasTagAttributes( nodeAfterSplit, splitTag, splitProperties ) ) {\r\n        block = createElement( nodeAfterSplit.ownerDocument,\r\n            splitTag, splitProperties );\r\n        if ( nodeAfterSplit.dir ) {\r\n            block.dir = nodeAfterSplit.dir;\r\n        }\r\n        replaceWith( nodeAfterSplit, block );\r\n        block.appendChild( empty( nodeAfterSplit ) );\r\n        nodeAfterSplit = block;\r\n    }\r\n    return nodeAfterSplit;\r\n};\r\n\r\nproto.forEachBlock = function ( fn, mutates, range ) {\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return this;\r\n    }\r\n\r\n    // Save undo checkpoint\r\n    if ( mutates ) {\r\n        this.saveUndoState( range );\r\n    }\r\n\r\n    var root = this._root;\r\n    var start = getStartBlockOfRange( range, root );\r\n    var end = getEndBlockOfRange( range, root );\r\n    if ( start && end ) {\r\n        do {\r\n            if ( fn( start ) || start === end ) { break; }\r\n        } while ( start = getNextBlock( start, root ) );\r\n    }\r\n\r\n    if ( mutates ) {\r\n        this.setSelection( range );\r\n\r\n        // Path may have changed\r\n        this._updatePath( range, true );\r\n\r\n        // We're not still in an undo state\r\n        if ( !canObserveMutations ) {\r\n            this._docWasChanged();\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\nproto.modifyBlocks = function ( modify, range ) {\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return this;\r\n    }\r\n\r\n    // 1. Save undo checkpoint and bookmark selection\r\n    this._recordUndoState( range, this._isInUndoState );\r\n\r\n    var root = this._root;\r\n    var frag;\r\n\r\n    // 2. Expand range to block boundaries\r\n    expandRangeToBlockBoundaries( range, root );\r\n\r\n    // 3. Remove range.\r\n    moveRangeBoundariesUpTree( range, root, root, root );\r\n    frag = extractContentsOfRange( range, root, root );\r\n\r\n    // 4. Modify tree of fragment and reinsert.\r\n    insertNodeInRange( range, modify.call( this, frag ) );\r\n\r\n    // 5. Merge containers at edges\r\n    if ( range.endOffset < range.endContainer.childNodes.length ) {\r\n        mergeContainers( range.endContainer.childNodes[ range.endOffset ], root );\r\n    }\r\n    mergeContainers( range.startContainer.childNodes[ range.startOffset ], root );\r\n\r\n    // 6. Restore selection\r\n    this._getRangeAndRemoveBookmark( range );\r\n    this.setSelection( range );\r\n    this._updatePath( range, true );\r\n\r\n    // 7. We're not still in an undo state\r\n    if ( !canObserveMutations ) {\r\n        this._docWasChanged();\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nvar increaseBlockQuoteLevel = function ( frag ) {\r\n    return this.createElement( 'BLOCKQUOTE',\r\n        this._config.tagAttributes.blockquote, [\r\n            frag\r\n        ]);\r\n};\r\n\r\nvar decreaseBlockQuoteLevel = function ( frag ) {\r\n    var root = this._root;\r\n    var blockquotes = frag.querySelectorAll( 'blockquote' );\r\n    Array.prototype.filter.call( blockquotes, function ( el ) {\r\n        return !getNearest( el.parentNode, root, 'BLOCKQUOTE' );\r\n    }).forEach( function ( el ) {\r\n        replaceWith( el, empty( el ) );\r\n    });\r\n    return frag;\r\n};\r\n\r\nvar removeBlockQuote = function (/* frag */) {\r\n    return this.createDefaultBlock([\r\n        this.createElement( 'INPUT', {\r\n            id: startSelectionId,\r\n            type: 'hidden'\r\n        }),\r\n        this.createElement( 'INPUT', {\r\n            id: endSelectionId,\r\n            type: 'hidden'\r\n        })\r\n    ]);\r\n};\r\n\r\nvar makeList = function ( self, frag, type ) {\r\n    var walker = getBlockWalker( frag, self._root ),\r\n        node, tag, prev, newLi,\r\n        tagAttributes = self._config.tagAttributes,\r\n        listAttrs = tagAttributes[ type.toLowerCase() ],\r\n        listItemAttrs = tagAttributes.li;\r\n\r\n    while ( node = walker.nextNode() ) {\r\n        if ( node.parentNode.nodeName === 'LI' ) {\r\n            node = node.parentNode;\r\n            walker.currentNode = node.lastChild;\r\n        }\r\n        if ( node.nodeName !== 'LI' ) {\r\n            newLi = self.createElement( 'LI', listItemAttrs );\r\n            if ( node.dir ) {\r\n                newLi.dir = node.dir;\r\n            }\r\n\r\n            // Have we replaced the previous block with a new <ul>/<ol>?\r\n            if ( ( prev = node.previousSibling ) && prev.nodeName === type ) {\r\n                prev.appendChild( newLi );\r\n                detach( node );\r\n            }\r\n            // Otherwise, replace this block with the <ul>/<ol>\r\n            else {\r\n                replaceWith(\r\n                    node,\r\n                    self.createElement( type, listAttrs, [\r\n                        newLi\r\n                    ])\r\n                );\r\n            }\r\n            newLi.appendChild( empty( node ) );\r\n            walker.currentNode = newLi;\r\n        } else {\r\n            node = node.parentNode;\r\n            tag = node.nodeName;\r\n            if ( tag !== type && ( /^[OU]L$/.test( tag ) ) ) {\r\n                replaceWith( node,\r\n                    self.createElement( type, listAttrs, [ empty( node ) ] )\r\n                );\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar makeUnorderedList = function ( frag ) {\r\n    makeList( this, frag, 'UL' );\r\n    return frag;\r\n};\r\n\r\nvar makeOrderedList = function ( frag ) {\r\n    makeList( this, frag, 'OL' );\r\n    return frag;\r\n};\r\n\r\nvar removeList = function ( frag ) {\r\n    var lists = frag.querySelectorAll( 'UL, OL' ),\r\n        items =  frag.querySelectorAll( 'LI' ),\r\n        root = this._root,\r\n        i, l, list, listFrag, item;\r\n    for ( i = 0, l = lists.length; i < l; i += 1 ) {\r\n        list = lists[i];\r\n        listFrag = empty( list );\r\n        fixContainer( listFrag, root );\r\n        replaceWith( list, listFrag );\r\n    }\r\n\r\n    for ( i = 0, l = items.length; i < l; i += 1 ) {\r\n        item = items[i];\r\n        if ( isBlock( item ) ) {\r\n            replaceWith( item,\r\n                this.createDefaultBlock([ empty( item ) ])\r\n            );\r\n        } else {\r\n            fixContainer( item, root );\r\n            replaceWith( item, empty( item ) );\r\n        }\r\n    }\r\n    return frag;\r\n};\r\n\r\nvar getListSelection = function ( range, root ) {\r\n    // Get start+end li in single common ancestor\r\n    var list = range.commonAncestorContainer;\r\n    var startLi = range.startContainer;\r\n    var endLi = range.endContainer;\r\n    while ( list && list !== root && !/^[OU]L$/.test( list.nodeName ) ) {\r\n        list = list.parentNode;\r\n    }\r\n    if ( !list || list === root ) {\r\n        return null;\r\n    }\r\n    if ( startLi === list ) {\r\n        startLi = startLi.childNodes[ range.startOffset ];\r\n    }\r\n    if ( endLi === list ) {\r\n        endLi = endLi.childNodes[ range.endOffset ];\r\n    }\r\n    while ( startLi && startLi.parentNode !== list ) {\r\n        startLi = startLi.parentNode;\r\n    }\r\n    while ( endLi && endLi.parentNode !== list ) {\r\n        endLi = endLi.parentNode;\r\n    }\r\n    return [ list, startLi, endLi ];\r\n};\r\n\r\nproto.increaseListLevel = function ( range ) {\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return this.focus();\r\n    }\r\n\r\n    var root = this._root;\r\n    var listSelection = getListSelection( range, root );\r\n    if ( !listSelection ) {\r\n        return this.focus();\r\n    }\r\n\r\n    var list = listSelection[0];\r\n    var startLi = listSelection[1];\r\n    var endLi = listSelection[2];\r\n    if ( !startLi || startLi === list.firstChild ) {\r\n        return this.focus();\r\n    }\r\n\r\n    // Save undo checkpoint and bookmark selection\r\n    this._recordUndoState( range, this._isInUndoState );\r\n\r\n    // Increase list depth\r\n    var type = list.nodeName;\r\n    var newParent = startLi.previousSibling;\r\n    var listAttrs, next;\r\n    if ( newParent.nodeName !== type ) {\r\n        listAttrs = this._config.tagAttributes[ type.toLowerCase() ];\r\n        newParent = this.createElement( type, listAttrs );\r\n        list.insertBefore( newParent, startLi );\r\n    }\r\n    do {\r\n        next = startLi === endLi ? null : startLi.nextSibling;\r\n        newParent.appendChild( startLi );\r\n    } while ( ( startLi = next ) );\r\n    next = newParent.nextSibling;\r\n    if ( next ) {\r\n        mergeContainers( next, root );\r\n    }\r\n\r\n    // Restore selection\r\n    this._getRangeAndRemoveBookmark( range );\r\n    this.setSelection( range );\r\n    this._updatePath( range, true );\r\n\r\n    // We're not still in an undo state\r\n    if ( !canObserveMutations ) {\r\n        this._docWasChanged();\r\n    }\r\n\r\n    return this.focus();\r\n};\r\n\r\nproto.decreaseListLevel = function ( range ) {\r\n    if ( !range && !( range = this.getSelection() ) ) {\r\n        return this.focus();\r\n    }\r\n\r\n    var root = this._root;\r\n    var listSelection = getListSelection( range, root );\r\n    if ( !listSelection ) {\r\n        return this.focus();\r\n    }\r\n\r\n    var list = listSelection[0];\r\n    var startLi = listSelection[1];\r\n    var endLi = listSelection[2];\r\n    if ( !startLi ) {\r\n        startLi = list.firstChild;\r\n    }\r\n    if ( !endLi ) {\r\n        endLi = list.lastChild;\r\n    }\r\n\r\n    // Save undo checkpoint and bookmark selection\r\n    this._recordUndoState( range, this._isInUndoState );\r\n\r\n    // Find the new parent list node\r\n    var newParent = list.parentNode;\r\n    var next;\r\n\r\n    // Split list if necesary\r\n    var insertBefore = !endLi.nextSibling ?\r\n        list.nextSibling :\r\n        split( list, endLi.nextSibling, newParent, root );\r\n\r\n    if ( newParent !== root && newParent.nodeName === 'LI' ) {\r\n        newParent = newParent.parentNode;\r\n        while ( insertBefore ) {\r\n            next = insertBefore.nextSibling;\r\n            endLi.appendChild( insertBefore );\r\n            insertBefore = next;\r\n        }\r\n        insertBefore = list.parentNode.nextSibling;\r\n    }\r\n\r\n    var makeNotList = !/^[OU]L$/.test( newParent.nodeName );\r\n    do {\r\n        next = startLi === endLi ? null : startLi.nextSibling;\r\n        list.removeChild( startLi );\r\n        if ( makeNotList && startLi.nodeName === 'LI' ) {\r\n            startLi = this.createDefaultBlock([ empty( startLi ) ]);\r\n        }\r\n        newParent.insertBefore( startLi, insertBefore );\r\n    } while ( ( startLi = next ) );\r\n\r\n    if ( !list.firstChild ) {\r\n        detach( list );\r\n    }\r\n\r\n    if ( insertBefore ) {\r\n        mergeContainers( insertBefore, root );\r\n    }\r\n\r\n    // Restore selection\r\n    this._getRangeAndRemoveBookmark( range );\r\n    this.setSelection( range );\r\n    this._updatePath( range, true );\r\n\r\n    // We're not still in an undo state\r\n    if ( !canObserveMutations ) {\r\n        this._docWasChanged();\r\n    }\r\n\r\n    return this.focus();\r\n};\r\n\r\nproto._ensureBottomLine = function () {\r\n    var root = this._root;\r\n    var last = root.lastElementChild;\r\n    if ( !last ||\r\n            last.nodeName !== this._config.blockTag || !isBlock( last ) ) {\r\n        root.appendChild( this.createDefaultBlock() );\r\n    }\r\n};\r\n\r\n// --- Keyboard interaction ---\r\n\r\nproto.setKeyHandler = function ( key, fn ) {\r\n    this._keyHandlers[ key ] = fn;\r\n    return this;\r\n};\r\n\r\n// --- Get/Set data ---\r\n\r\nproto._getHTML = function () {\r\n    return this._root.innerHTML;\r\n};\r\n\r\nproto._setHTML = function ( html ) {\r\n    var root = this._root;\r\n    var node = root;\r\n    node.innerHTML = html;\r\n    do {\r\n        fixCursor( node, root );\r\n    } while ( node = getNextBlock( node, root ) );\r\n    this._ignoreChange = true;\r\n};\r\n\r\nproto.getHTML = function ( withBookMark ) {\r\n    var brs = [],\r\n        root, node, fixer, html, l, range;\r\n    if ( withBookMark && ( range = this.getSelection() ) ) {\r\n        this._saveRangeToBookmark( range );\r\n    }\r\n    if ( useTextFixer ) {\r\n        root = this._root;\r\n        node = root;\r\n        while ( node = getNextBlock( node, root ) ) {\r\n            if ( !node.textContent && !node.querySelector( 'BR' ) ) {\r\n                fixer = this.createElement( 'BR' );\r\n                node.appendChild( fixer );\r\n                brs.push( fixer );\r\n            }\r\n        }\r\n    }\r\n    html = this._getHTML().replace( /\\u200B/g, '' );\r\n    if ( useTextFixer ) {\r\n        l = brs.length;\r\n        while ( l-- ) {\r\n            detach( brs[l] );\r\n        }\r\n    }\r\n    if ( range ) {\r\n        this._getRangeAndRemoveBookmark( range );\r\n    }\r\n    return html;\r\n};\r\n\r\nproto.setHTML = function ( html ) {\r\n    var config = this._config;\r\n    var sanitizeToDOMFragment = config.isSetHTMLSanitized ?\r\n            config.sanitizeToDOMFragment : null;\r\n    var root = this._root;\r\n    var div, frag, child;\r\n\r\n    // Parse HTML into DOM tree\r\n    if ( typeof sanitizeToDOMFragment === 'function' ) {\r\n        frag = sanitizeToDOMFragment( html, false, this );\r\n    } else {\r\n        div = this.createElement( 'DIV' );\r\n        div.innerHTML = html;\r\n        frag = this._doc.createDocumentFragment();\r\n        frag.appendChild( empty( div ) );\r\n    }\r\n\r\n    cleanTree( frag );\r\n    cleanupBRs( frag, root, false );\r\n\r\n    fixContainer( frag, root );\r\n\r\n    // Fix cursor\r\n    var node = frag;\r\n    while ( node = getNextBlock( node, root ) ) {\r\n        fixCursor( node, root );\r\n    }\r\n\r\n    // Don't fire an input event\r\n    this._ignoreChange = true;\r\n\r\n    // Remove existing root children\r\n    while ( child = root.lastChild ) {\r\n        root.removeChild( child );\r\n    }\r\n\r\n    // And insert new content\r\n    root.appendChild( frag );\r\n    fixCursor( root, root );\r\n\r\n    // Reset the undo stack\r\n    this._undoIndex = -1;\r\n    this._undoStack.length = 0;\r\n    this._undoStackLength = 0;\r\n    this._isInUndoState = false;\r\n\r\n    // Record undo state\r\n    var range = this._getRangeAndRemoveBookmark() ||\r\n        this._createRange( root.firstChild, 0 );\r\n    this.saveUndoState( range );\r\n    // IE will also set focus when selecting text so don't use\r\n    // setSelection. Instead, just store it in lastSelection, so if\r\n    // anything calls getSelection before first focus, we have a range\r\n    // to return.\r\n    this._lastSelection = range;\r\n    enableRestoreSelection.call( this );\r\n    this._updatePath( range, true );\r\n\r\n    return this;\r\n};\r\n\r\nproto.insertElement = function ( el, range ) {\r\n    if ( !range ) {\r\n        range = this.getSelection();\r\n    }\r\n    range.collapse( true );\r\n    if ( isInline( el ) ) {\r\n        insertNodeInRange( range, el );\r\n        range.setStartAfter( el );\r\n    } else {\r\n        // Get containing block node.\r\n        var root = this._root;\r\n        var splitNode = getStartBlockOfRange( range, root ) || root;\r\n        var parent, nodeAfterSplit;\r\n        // While at end of container node, move up DOM tree.\r\n        while ( splitNode !== root && !splitNode.nextSibling ) {\r\n            splitNode = splitNode.parentNode;\r\n        }\r\n        // If in the middle of a container node, split up to root.\r\n        if ( splitNode !== root ) {\r\n            parent = splitNode.parentNode;\r\n            nodeAfterSplit = split( parent, splitNode.nextSibling, root, root );\r\n        }\r\n        if ( nodeAfterSplit ) {\r\n            root.insertBefore( el, nodeAfterSplit );\r\n        } else {\r\n            root.appendChild( el );\r\n            // Insert blank line below block.\r\n            nodeAfterSplit = this.createDefaultBlock();\r\n            root.appendChild( nodeAfterSplit );\r\n        }\r\n        range.setStart( nodeAfterSplit, 0 );\r\n        range.setEnd( nodeAfterSplit, 0 );\r\n        moveRangeBoundariesDownTree( range );\r\n    }\r\n    this.focus();\r\n    this.setSelection( range );\r\n    this._updatePath( range );\r\n\r\n    if ( !canObserveMutations ) {\r\n        this._docWasChanged();\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\nproto.insertImage = function ( src, attributes ) {\r\n    var img = this.createElement( 'IMG', mergeObjects({\r\n        src: src\r\n    }, attributes, true ));\r\n    this.insertElement( img );\r\n    return img;\r\n};\r\n\r\nvar linkRegExp = /\\b((?:(?:ht|f)tps?:\\/\\/|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,}\\/)(?:[^\\s()<>]+|\\([^\\s()<>]+\\))+(?:\\((?:[^\\s()<>]+|(?:\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?«»“”‘’]))|([\\w\\-.%+]+@(?:[\\w\\-]+\\.)+[A-Z]{2,}\\b)/i;\r\n\r\nvar addLinks = function ( frag, root, self ) {\r\n    var doc = frag.ownerDocument,\r\n        walker = new TreeWalker( frag, SHOW_TEXT,\r\n                function ( node ) {\r\n            return !getNearest( node, root, 'A' );\r\n        }, false ),\r\n        defaultAttributes = self._config.tagAttributes.a,\r\n        node, data, parent, match, index, endIndex, child;\r\n    while ( node = walker.nextNode() ) {\r\n        data = node.data;\r\n        parent = node.parentNode;\r\n        while ( match = linkRegExp.exec( data ) ) {\r\n            index = match.index;\r\n            endIndex = index + match[0].length;\r\n            if ( index ) {\r\n                child = doc.createTextNode( data.slice( 0, index ) );\r\n                parent.insertBefore( child, node );\r\n            }\r\n            child = self.createElement( 'A', mergeObjects({\r\n                href: match[1] ?\r\n                    /^(?:ht|f)tps?:/.test( match[1] ) ?\r\n                        match[1] :\r\n                        'http://' + match[1] :\r\n                    'mailto:' + match[2]\r\n            }, defaultAttributes, false ));\r\n            child.textContent = data.slice( index, endIndex );\r\n            parent.insertBefore( child, node );\r\n            node.data = data = data.slice( endIndex );\r\n        }\r\n    }\r\n};\r\n\r\n// Insert HTML at the cursor location. If the selection is not collapsed\r\n// insertTreeFragmentIntoRange will delete the selection so that it is replaced\r\n// by the html being inserted.\r\nproto.insertHTML = function ( html, isPaste ) {\r\n    var config = this._config;\r\n    var sanitizeToDOMFragment = config.isInsertedHTMLSanitized ?\r\n            config.sanitizeToDOMFragment : null;\r\n    var range = this.getSelection();\r\n    var doc = this._doc;\r\n    var startFragmentIndex, endFragmentIndex;\r\n    var div, frag, root, node, event;\r\n\r\n    // Edge doesn't just copy the fragment, but includes the surrounding guff\r\n    // including the full <head> of the page. Need to strip this out. If\r\n    // available use DOMPurify to parse and sanitise.\r\n    if ( typeof sanitizeToDOMFragment === 'function' ) {\r\n        frag = sanitizeToDOMFragment( html, isPaste, this );\r\n    } else {\r\n        if ( isPaste ) {\r\n            startFragmentIndex = html.indexOf( '<!--StartFragment-->' );\r\n            endFragmentIndex = html.lastIndexOf( '<!--EndFragment-->' );\r\n            if ( startFragmentIndex > -1 && endFragmentIndex > -1 ) {\r\n                html = html.slice( startFragmentIndex + 20, endFragmentIndex );\r\n            }\r\n        }\r\n        // Wrap with <tr> if html contains dangling <td> tags\r\n        if ( /<\\/td>((?!<\\/tr>)[\\s\\S])*$/i.test( html ) ) {\r\n            html = '<TR>' + html + '</TR>';\r\n        }\r\n        // Wrap with <table> if html contains dangling <tr> tags\r\n        if ( /<\\/tr>((?!<\\/table>)[\\s\\S])*$/i.test( html ) ) {\r\n            html = '<TABLE>' + html + '</TABLE>';\r\n        }\r\n        // Parse HTML into DOM tree\r\n        div = this.createElement( 'DIV' );\r\n        div.innerHTML = html;\r\n        frag = doc.createDocumentFragment();\r\n        frag.appendChild( empty( div ) );\r\n    }\r\n\r\n    // Record undo checkpoint\r\n    this.saveUndoState( range );\r\n\r\n    try {\r\n        root = this._root;\r\n        node = frag;\r\n        event = {\r\n            fragment: frag,\r\n            preventDefault: function () {\r\n                this.defaultPrevented = true;\r\n            },\r\n            defaultPrevented: false\r\n        };\r\n\r\n        addLinks( frag, frag, this );\r\n        cleanTree( frag );\r\n        cleanupBRs( frag, root, false );\r\n        removeEmptyInlines( frag );\r\n        frag.normalize();\r\n\r\n        while ( node = getNextBlock( node, frag ) ) {\r\n            fixCursor( node, root );\r\n        }\r\n\r\n        if ( isPaste ) {\r\n            this.fireEvent( 'willPaste', event );\r\n        }\r\n\r\n        if ( !event.defaultPrevented ) {\r\n            insertTreeFragmentIntoRange( range, event.fragment, root );\r\n            if ( !canObserveMutations ) {\r\n                this._docWasChanged();\r\n            }\r\n            range.collapse( false );\r\n            this._ensureBottomLine();\r\n        }\r\n\r\n        this.setSelection( range );\r\n        this._updatePath( range, true );\r\n        // Safari sometimes loses focus after paste. Weird.\r\n        if ( isPaste ) {\r\n            this.focus();\r\n        }\r\n    } catch ( error ) {\r\n        this.didError( error );\r\n    }\r\n    return this;\r\n};\r\n\r\nvar escapeHTMLFragement = function ( text ) {\r\n    return text.split( '&' ).join( '&amp;' )\r\n               .split( '<' ).join( '&lt;'  )\r\n               .split( '>' ).join( '&gt;'  )\r\n               .split( '\"' ).join( '&quot;'  );\r\n};\r\n\r\nproto.insertPlainText = function ( plainText, isPaste ) {\r\n    var lines = plainText.split( '\\n' );\r\n    var config = this._config;\r\n    var tag = config.blockTag;\r\n    var attributes = config.blockAttributes;\r\n    var closeBlock  = '</' + tag + '>';\r\n    var openBlock = '<' + tag;\r\n    var attr, i, l, line;\r\n\r\n    for ( attr in attributes ) {\r\n        openBlock += ' ' + attr + '=\"' +\r\n            escapeHTMLFragement( attributes[ attr ] ) +\r\n        '\"';\r\n    }\r\n    openBlock += '>';\r\n\r\n    for ( i = 0, l = lines.length; i < l; i += 1 ) {\r\n        line = lines[i];\r\n        line = escapeHTMLFragement( line ).replace( / (?= )/g, '&nbsp;' );\r\n        // Wrap each line in <div></div>\r\n        lines[i] = openBlock + ( line || '<BR>' ) + closeBlock;\r\n    }\r\n    return this.insertHTML( lines.join( '' ), isPaste );\r\n};\r\n\r\n// --- Formatting ---\r\n\r\nvar command = function ( method, arg, arg2 ) {\r\n    return function () {\r\n        this[ method ]( arg, arg2 );\r\n        return this.focus();\r\n    };\r\n};\r\n\r\nproto.addStyles = function ( styles ) {\r\n    if ( styles ) {\r\n        var head = this._doc.documentElement.firstChild,\r\n            style = this.createElement( 'STYLE', {\r\n                type: 'text/css'\r\n            });\r\n        style.appendChild( this._doc.createTextNode( styles ) );\r\n        head.appendChild( style );\r\n    }\r\n    return this;\r\n};\r\n\r\nproto.bold = command( 'changeFormat', { tag: 'B' } );\r\nproto.italic = command( 'changeFormat', { tag: 'I' } );\r\nproto.underline = command( 'changeFormat', { tag: 'U' } );\r\nproto.strikethrough = command( 'changeFormat', { tag: 'S' } );\r\nproto.subscript = command( 'changeFormat', { tag: 'SUB' }, { tag: 'SUP' } );\r\nproto.superscript = command( 'changeFormat', { tag: 'SUP' }, { tag: 'SUB' } );\r\n\r\nproto.removeBold = command( 'changeFormat', null, { tag: 'B' } );\r\nproto.removeItalic = command( 'changeFormat', null, { tag: 'I' } );\r\nproto.removeUnderline = command( 'changeFormat', null, { tag: 'U' } );\r\nproto.removeStrikethrough = command( 'changeFormat', null, { tag: 'S' } );\r\nproto.removeSubscript = command( 'changeFormat', null, { tag: 'SUB' } );\r\nproto.removeSuperscript = command( 'changeFormat', null, { tag: 'SUP' } );\r\n\r\nproto.makeLink = function ( url, attributes ) {\r\n    var range = this.getSelection();\r\n    if ( range.collapsed ) {\r\n        var protocolEnd = url.indexOf( ':' ) + 1;\r\n        if ( protocolEnd ) {\r\n            while ( url[ protocolEnd ] === '/' ) { protocolEnd += 1; }\r\n        }\r\n        insertNodeInRange(\r\n            range,\r\n            this._doc.createTextNode( url.slice( protocolEnd ) )\r\n        );\r\n    }\r\n    attributes = mergeObjects(\r\n        mergeObjects({\r\n            href: url\r\n        }, attributes, true ),\r\n        this._config.tagAttributes.a,\r\n        false\r\n    );\r\n\r\n    this.changeFormat({\r\n        tag: 'A',\r\n        attributes: attributes\r\n    }, {\r\n        tag: 'A'\r\n    }, range );\r\n    return this.focus();\r\n};\r\nproto.removeLink = function () {\r\n    this.changeFormat( null, {\r\n        tag: 'A'\r\n    }, this.getSelection(), true );\r\n    return this.focus();\r\n};\r\n\r\nproto.setFontFace = function ( name ) {\r\n    this.changeFormat( name ? {\r\n        tag: 'SPAN',\r\n        attributes: {\r\n            'class': FONT_FAMILY_CLASS,\r\n            style: 'font-family: ' + name + ', sans-serif;'\r\n        }\r\n    } : null, {\r\n        tag: 'SPAN',\r\n        attributes: { 'class': FONT_FAMILY_CLASS }\r\n    });\r\n    return this.focus();\r\n};\r\nproto.setFontSize = function ( size ) {\r\n    this.changeFormat( size ? {\r\n        tag: 'SPAN',\r\n        attributes: {\r\n            'class': FONT_SIZE_CLASS,\r\n            style: 'font-size: ' +\r\n                ( typeof size === 'number' ? size + 'px' : size )\r\n        }\r\n    } : null, {\r\n        tag: 'SPAN',\r\n        attributes: { 'class': FONT_SIZE_CLASS }\r\n    });\r\n    return this.focus();\r\n};\r\n\r\nproto.setTextColour = function ( colour ) {\r\n    this.changeFormat( colour ? {\r\n        tag: 'SPAN',\r\n        attributes: {\r\n            'class': COLOUR_CLASS,\r\n            style: 'color:' + colour\r\n        }\r\n    } : null, {\r\n        tag: 'SPAN',\r\n        attributes: { 'class': COLOUR_CLASS }\r\n    });\r\n    return this.focus();\r\n};\r\n\r\nproto.setHighlightColour = function ( colour ) {\r\n    this.changeFormat( colour ? {\r\n        tag: 'SPAN',\r\n        attributes: {\r\n            'class': HIGHLIGHT_CLASS,\r\n            style: 'background-color:' + colour\r\n        }\r\n    } : colour, {\r\n        tag: 'SPAN',\r\n        attributes: { 'class': HIGHLIGHT_CLASS }\r\n    });\r\n    return this.focus();\r\n};\r\n\r\nproto.setTextAlignment = function ( alignment ) {\r\n    this.forEachBlock( function ( block ) {\r\n        var className = block.className\r\n            .split( /\\s+/ )\r\n            .filter( function ( klass ) {\r\n                return !!klass && !/^align/.test( klass );\r\n            })\r\n            .join( ' ' );\r\n        if ( alignment ) {\r\n            block.className = className + ' align-' + alignment;\r\n            block.style.textAlign = alignment;\r\n        } else {\r\n            block.className = className;\r\n            block.style.textAlign = '';\r\n        }\r\n    }, true );\r\n    return this.focus();\r\n};\r\n\r\nproto.setTextDirection = function ( direction ) {\r\n    this.forEachBlock( function ( block ) {\r\n        if ( direction ) {\r\n            block.dir = direction;\r\n        } else {\r\n            block.removeAttribute( 'dir' );\r\n        }\r\n    }, true );\r\n    return this.focus();\r\n};\r\n\r\nfunction removeFormatting ( self, root, clean ) {\r\n    var node, next;\r\n    for ( node = root.firstChild; node; node = next ) {\r\n        next = node.nextSibling;\r\n        if ( isInline( node ) ) {\r\n            if ( node.nodeType === TEXT_NODE || node.nodeName === 'BR' || node.nodeName === 'IMG' ) {\r\n                clean.appendChild( node );\r\n                continue;\r\n            }\r\n        } else if ( isBlock( node ) ) {\r\n            clean.appendChild( self.createDefaultBlock([\r\n                removeFormatting(\r\n                    self, node, self._doc.createDocumentFragment() )\r\n            ]));\r\n            continue;\r\n        }\r\n        removeFormatting( self, node, clean );\r\n    }\r\n    return clean;\r\n}\r\n\r\nproto.removeAllFormatting = function ( range ) {\r\n    if ( !range && !( range = this.getSelection() ) || range.collapsed ) {\r\n        return this;\r\n    }\r\n\r\n    var root = this._root;\r\n    var stopNode = range.commonAncestorContainer;\r\n    while ( stopNode && !isBlock( stopNode ) ) {\r\n        stopNode = stopNode.parentNode;\r\n    }\r\n    if ( !stopNode ) {\r\n        expandRangeToBlockBoundaries( range, root );\r\n        stopNode = root;\r\n    }\r\n    if ( stopNode.nodeType === TEXT_NODE ) {\r\n        return this;\r\n    }\r\n\r\n    // Record undo point\r\n    this.saveUndoState( range );\r\n\r\n    // Avoid splitting where we're already at edges.\r\n    moveRangeBoundariesUpTree( range, stopNode, stopNode, root );\r\n\r\n    // Split the selection up to the block, or if whole selection in same\r\n    // block, expand range boundaries to ends of block and split up to root.\r\n    var doc = stopNode.ownerDocument;\r\n    var startContainer = range.startContainer;\r\n    var startOffset = range.startOffset;\r\n    var endContainer = range.endContainer;\r\n    var endOffset = range.endOffset;\r\n\r\n    // Split end point first to avoid problems when end and start\r\n    // in same container.\r\n    var formattedNodes = doc.createDocumentFragment();\r\n    var cleanNodes = doc.createDocumentFragment();\r\n    var nodeAfterSplit = split( endContainer, endOffset, stopNode, root );\r\n    var nodeInSplit = split( startContainer, startOffset, stopNode, root );\r\n    var nextNode, childNodes;\r\n\r\n    // Then replace contents in split with a cleaned version of the same:\r\n    // blocks become default blocks, text and leaf nodes survive, everything\r\n    // else is obliterated.\r\n    while ( nodeInSplit !== nodeAfterSplit ) {\r\n        nextNode = nodeInSplit.nextSibling;\r\n        formattedNodes.appendChild( nodeInSplit );\r\n        nodeInSplit = nextNode;\r\n    }\r\n    removeFormatting( this, formattedNodes, cleanNodes );\r\n    cleanNodes.normalize();\r\n    nodeInSplit = cleanNodes.firstChild;\r\n    nextNode = cleanNodes.lastChild;\r\n\r\n    // Restore selection\r\n    childNodes = stopNode.childNodes;\r\n    if ( nodeInSplit ) {\r\n        stopNode.insertBefore( cleanNodes, nodeAfterSplit );\r\n        startOffset = indexOf.call( childNodes, nodeInSplit );\r\n        endOffset = indexOf.call( childNodes, nextNode ) + 1;\r\n    } else {\r\n        startOffset = indexOf.call( childNodes, nodeAfterSplit );\r\n        endOffset = startOffset;\r\n    }\r\n\r\n    // Merge text nodes at edges, if possible\r\n    range.setStart( stopNode, startOffset );\r\n    range.setEnd( stopNode, endOffset );\r\n    mergeInlines( stopNode, range );\r\n\r\n    // And move back down the tree\r\n    moveRangeBoundariesDownTree( range );\r\n\r\n    this.setSelection( range );\r\n    this._updatePath( range, true );\r\n\r\n    return this.focus();\r\n};\r\n\r\nproto.increaseQuoteLevel = command( 'modifyBlocks', increaseBlockQuoteLevel );\r\nproto.decreaseQuoteLevel = command( 'modifyBlocks', decreaseBlockQuoteLevel );\r\n\r\nproto.makeUnorderedList = command( 'modifyBlocks', makeUnorderedList );\r\nproto.makeOrderedList = command( 'modifyBlocks', makeOrderedList );\r\nproto.removeList = command( 'modifyBlocks', removeList );\r\n\r\n// Node.js exports\r\nSquire.isInline = isInline;\r\nSquire.isBlock = isBlock;\r\nSquire.isContainer = isContainer;\r\nSquire.getBlockWalker = getBlockWalker;\r\nSquire.getPreviousBlock = getPreviousBlock;\r\nSquire.getNextBlock = getNextBlock;\r\nSquire.areAlike = areAlike;\r\nSquire.hasTagAttributes = hasTagAttributes;\r\nSquire.getNearest = getNearest;\r\nSquire.isOrContains = isOrContains;\r\nSquire.detach = detach;\r\nSquire.replaceWith = replaceWith;\r\nSquire.empty = empty;\r\n\r\n// Range.js exports\r\nSquire.getNodeBefore = getNodeBefore;\r\nSquire.getNodeAfter = getNodeAfter;\r\nSquire.insertNodeInRange = insertNodeInRange;\r\nSquire.extractContentsOfRange = extractContentsOfRange;\r\nSquire.deleteContentsOfRange = deleteContentsOfRange;\r\nSquire.insertTreeFragmentIntoRange = insertTreeFragmentIntoRange;\r\nSquire.isNodeContainedInRange = isNodeContainedInRange;\r\nSquire.moveRangeBoundariesDownTree = moveRangeBoundariesDownTree;\r\nSquire.moveRangeBoundariesUpTree = moveRangeBoundariesUpTree;\r\nSquire.getStartBlockOfRange = getStartBlockOfRange;\r\nSquire.getEndBlockOfRange = getEndBlockOfRange;\r\nSquire.contentWalker = contentWalker;\r\nSquire.rangeDoesStartAtBlockBoundary = rangeDoesStartAtBlockBoundary;\r\nSquire.rangeDoesEndAtBlockBoundary = rangeDoesEndAtBlockBoundary;\r\nSquire.expandRangeToBlockBoundaries = expandRangeToBlockBoundaries;\r\n\r\n// Clipboard.js exports\r\nSquire.onPaste = onPaste;\r\n\r\n// Editor.js exports\r\nSquire.addLinks = addLinks;\r\nSquire.splitBlock = splitBlock;\r\nSquire.startSelectionId = startSelectionId;\r\nSquire.endSelectionId = endSelectionId;\r\n\r\nif ( typeof exports === 'object' ) {\r\n    module.exports = Squire;\r\n} else if ( typeof define === 'function' && define.amd ) {\r\n    define( function () {\r\n        return Squire;\r\n    });\r\n} else {\r\n    win.Squire = Squire;\r\n\r\n    if ( top !== win &&\r\n            doc.documentElement.getAttribute( 'data-squireinit' ) === 'true' ) {\r\n        win.editor = new Squire( doc );\r\n        if ( win.onEditorLoad ) {\r\n            win.onEditorLoad( win.editor );\r\n            win.onEditorLoad = null;\r\n        }\r\n    }\r\n}\r\n\r\n}( document ) );\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/squire/squire-raw.js","var $export = require('./_export');\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: require('./_object-create') });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.create.js\n// module id = sF+V\n// module chunks = 1 2","// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of\nrequire('./_set-collection-of')('WeakMap');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es7.weak-map.of.js\n// module id = tGP/\n// module chunks = 1 2"],"sourceRoot":""}